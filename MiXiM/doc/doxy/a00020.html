<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: BaseDecider Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MiXiM
   &#160;<span id="projectnumber">2.3</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00020.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">BaseDecider Class Reference<div class="ingroups"><a class="el" href="a00512.html">decider - decider modules</a> &#124; <a class="el" href="a00516.html">baseModules - base module classes of MiXiM</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="BaseDecider" --><!-- doxytag: inherits="Decider" -->
<p>Provides some base functionality for most common deciders.  
 <a href="a00020.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00283_source.html">BaseDecider.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BaseDecider:</div>
<div class="dyncontent">
<div class="center"><img src="a00574.png" border="0" usemap="#BaseDecider_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for BaseDecider:</div>
<div class="dyncontent">
<div class="center"><img src="a00575.png" border="0" usemap="#BaseDecider_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00576.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">tCSRInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data about an currently ongoing ChannelSenseRequest.  <a href="a00206.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html">tProcessingSignal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of a AirFrame and the state it is in.  <a href="a00215.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a7232c10b806ef074db6b1452664cc4a2">BaseDeciderControlKinds</a> { <a class="el" href="a00020.html#a7232c10b806ef074db6b1452664cc4a2ab80ab87167f9836332d1d5678f6aab64">PACKET_DROPPED</a> =  22100, 
<a class="el" href="a00020.html#a7232c10b806ef074db6b1452664cc4a2a1944cc67bf3f0c98342e3975bd05021c">LAST_BASE_DECIDER_CONTROL_KIND</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinds of ControlMessages this <a class="el" href="a00070.html" title="The basic Decider class.">Decider</a> sends.  <a href="a00020.html#a7232c10b806ef074db6b1452664cc4a2">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#acff4618fa7a9c2e9abf257e60e487de2">BaseDecider</a> (<a class="el" href="a00079.html">DeciderToPhyInterface</a> *<a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">phy</a>, double <a class="el" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0">sensitivity</a>, int <a class="el" href="a00020.html#a33e7f02028e78116193d09d6cdbc987e">myIndex</a>, bool <a class="el" href="a00020.html#aa22cd5156240713e37578172ba5557ce">debug</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the decider with the passed values.  <a href="#acff4618fa7a9c2e9abf257e60e487de2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a066c6bb5c11795e973d14157ea3a9c64">processSignal</a> (<a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes an AirFrame given by the <a class="el" href="a00173.html" title="Provides initialisation for several AnalogueModels and Deciders from modules directory.">PhyLayer</a>.  <a href="#a066c6bb5c11795e973d14157ea3a9c64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3c39418955737e6bae1a71a4b86d518"></a><!-- doxytag: member="BaseDecider::cancelProcessSignal" ref="ae3c39418955737e6bae1a71a4b86d518" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ae3c39418955737e6bae1a71a4b86d518">cancelProcessSignal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels processing a AirFrame. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00044.html">ChannelState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a35e3f8f4e683747fbec1618ee1608982">getChannelState</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that returns information about the channel state.  <a href="#a35e3f8f4e683747fbec1618ee1608982"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#afd31e5a65d1798d329ace9bdbec25d64">handleChannelSenseRequest</a> (ChannelSenseRequest *request)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the <a class="el" href="a00173.html" title="Provides initialisation for several AnalogueModels and Deciders from modules directory.">PhyLayer</a> to hand over a ChannelSenseRequest.  <a href="#afd31e5a65d1798d329ace9bdbec25d64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a1807c7256b577fe24cdd8e9c839f1d20">channelChanged</a> (int newChannel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by phy layer to indicate that the channel this radio currently listens to has changed.  <a href="#a1807c7256b577fe24cdd8e9c839f1d20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d59c0be545b6d7db1233c2bb256eb5d"></a><!-- doxytag: member="BaseDecider::finish" ref="a3d59c0be545b6d7db1233c2bb256eb5d" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a3d59c0be545b6d7db1233c2bb256eb5d">finish</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to be called by an OMNeT-module during its own <a class="el" href="a00020.html#a3d59c0be545b6d7db1233c2bb256eb5d" title="Method to be called by an OMNeT-module during its own finish(), to enable a decider to do some things...">finish()</a>, to enable a decider to do some things. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">eSignalState</a> { <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31">NEW</a>, 
<a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6">EXPECT_HEADER</a>, 
<a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa5539b8e545c0676dab0b0efb80dfeeac">EXPECT_END</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of processing for a signal.  <a href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa13822e21b4389a929359e581c4ec659"></a><!-- doxytag: member="BaseDecider::ReceivedSignal" ref="aa13822e21b4389a929359e581c4ec659" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="a00215.html">BaseDecider::tProcessingSignal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aa13822e21b4389a929359e581c4ec659">ReceivedSignal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of a AirFrame and the state it is in. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b6737edc0aa4a9c90f2da7b090caf76"></a><!-- doxytag: member="BaseDecider::CSRInfo" ref="a2b6737edc0aa4a9c90f2da7b090caf76" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="a00206.html">BaseDecider::tCSRInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a2b6737edc0aa4a9c90f2da7b090caf76">CSRInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data about an currently ongoing ChannelSenseRequest. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; double, <br class="typebreak"/>
simtime_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a5f79c1bbb4b39c82164e0805e1eeb699">channel_sense_rssi_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of <a class="el" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c" title="Calculates the RSSI value for the passed interval.">BaseDecider::calcChannelSenseRSSI</a> function.  <a href="#a5f79c1bbb4b39c82164e0805e1eeb699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="a00136.html">Mapping</a> <br class="typebreak"/>
*, channel_sense_rssi_t::second_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aa11a3ec12ab83f9223d7bf11279e6226">rssi_mapping_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of <a class="el" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20" title="Calculates a RSSI-Mapping (or Noise-Strength-Mapping) for a Signal.">BaseDecider::calculateRSSIMapping</a> function.  <a href="#aa11a3ec12ab83f9223d7bf11279e6226"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a9f433fe8b7693074d3121320e50c85e3">getFrameReceivingPower</a> (<a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the receive power of given frame.  <a href="#a9f433fe8b7693074d3121320e50c85e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">eSignalState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a4a8ddbaf158b593d4aabeac39c1d36ad">getNextSignalState</a> (<a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">eSignalState</a> CurState) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next signal state (END, HEADER, NEW).  <a href="#a4a8ddbaf158b593d4aabeac39c1d36ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a5e45eb03d1a7f3653385181236714f21">getNextSignalHandleTime</a> (const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next handle time for scheduler.  <a href="#a5e45eb03d1a7f3653385181236714f21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aa2a5b719b17153ecd9decb7dce98a0d1">processNewSignal</a> (<a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes a new <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>. Returns the time it wants to handle the signal again.  <a href="#aa2a5b719b17153ecd9decb7dce98a0d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ab53849078ba0481ea80a8926bdedd5f0">processSignalHeader</a> (<a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the end of the header of a received <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>.  <a href="#ab53849078ba0481ea80a8926bdedd5f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00075.html">DeciderResult</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac6ef3a4cf1b91bcec788b540d61bfeba">createResult</a> (const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="a00075.html" title="A class to represent the result of a processed packet (that is not noise) by the Decider.">DeciderResult</a> from frame.  <a href="#ac6ef3a4cf1b91bcec788b540d61bfeba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a6ff53fb85a926f2d6bdf8dd9164ee0c7">processSignalEnd</a> (<a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the end of a received <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>.  <a href="#a6ff53fb85a926f2d6bdf8dd9164ee0c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacce0cd3c123c63be6acfd773f936910"></a><!-- doxytag: member="BaseDecider::processUnknownSignal" ref="aacce0cd3c123c63be6acfd773f936910" args="(airframe_ptr_t frame)" -->
virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aacce0cd3c123c63be6acfd773f936910">processUnknownSignal</a> (<a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes any <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a> for which no state could be found. (is an error case). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">eSignalState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a53c0ec4fdf4f47e54fc1e8c757a18f91">getSignalState</a> (const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SignalState for the passed AirFrame.  <a href="#a53c0ec4fdf4f47e54fc1e8c757a18f91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a448a9f952964b494f44e5f5aef1313aa"></a><!-- doxytag: member="BaseDecider::setSignalState" ref="a448a9f952964b494f44e5f5aef1313aa" args="(const airframe_ptr_t frame, eSignalState newState)" -->
virtual <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">eSignalState</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setSignalState</b> (const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame, <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">eSignalState</a> newState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dba383c238fba606279ef483b435f78"></a><!-- doxytag: member="BaseDecider::handleNewSenseRequest" ref="a1dba383c238fba606279ef483b435f78" args="(ChannelSenseRequest *request)" -->
virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a1dba383c238fba606279ef483b435f78">handleNewSenseRequest</a> (ChannelSenseRequest *request)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a new incoming ChannelSenseRequest and returns the next (or latest) time to handle the request again. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a2f175306cc0ae9d2805bc050315a47d8">handleSenseRequestEnd</a> (<a class="el" href="a00020.html#a2b6737edc0aa4a9c90f2da7b090caf76">CSRInfo</a> &amp;requestInfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the timeout or end of a ChannelSenseRequest by calculating the <a class="el" href="a00044.html" title="Provides information about the current state of the channel:">ChannelState</a> and returning the request to the mac layer.  <a href="#a2f175306cc0ae9d2805bc050315a47d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6c1c16f5d0f3c18dd029aa9cac256a6"></a><!-- doxytag: member="BaseDecider::canAnswerCSR" ref="ab6c1c16f5d0f3c18dd029aa9cac256a6" args="(const CSRInfo &amp;requestInfo) const " -->
virtual simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ab6c1c16f5d0f3c18dd029aa9cac256a6">canAnswerCSR</a> (const <a class="el" href="a00020.html#a2b6737edc0aa4a9c90f2da7b090caf76">CSRInfo</a> &amp;requestInfo) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns point in time when the ChannelSenseRequest of the passed CSRInfo can be answered (e.g. because channel state changed or timeout is reached). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00020.html#a5f79c1bbb4b39c82164e0805e1eeb699">channel_sense_rssi_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c">calcChannelSenseRSSI</a> (simtime_t_cref start, simtime_t_cref end) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the RSSI value for the passed interval.  <a href="#ac7a2b437d463db0f1f8f85d5a9685c2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ab8e925001d1f8630338c50f8ec10bb0d">answerCSR</a> (<a class="el" href="a00020.html#a2b6737edc0aa4a9c90f2da7b090caf76">CSRInfo</a> &amp;requestInfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Answers the ChannelSenseRequest (CSR) from the passed CSRInfo.  <a href="#ab8e925001d1f8630338c50f8ec10bb0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#add7242168c4bb521c6335f3de590e4b0">channelStateChanged</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the changed channel state enables us to answer any ongoing ChannelSenseRequests.  <a href="#add7242168c4bb521c6335f3de590e4b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a0310d4013043026404832008d40d48b9">getChannelInfo</a> (simtime_t_cref start, simtime_t_cref end, <a class="el" href="a00070.html#a6baab300e0bec90320dfe956c2d15a57">AirFrameVector</a> &amp;out) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects the AirFrame on the channel during the passed interval.  <a href="#a0310d4013043026404832008d40d48b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aea9e98c3a9752bcf08e42742b01d2fe3">calculateSnrMapping</a> (const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> frame) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a SNR-Mapping for a <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>.  <a href="#aea9e98c3a9752bcf08e42742b01d2fe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00020.html#aa11a3ec12ab83f9223d7bf11279e6226">rssi_mapping_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20">calculateRSSIMapping</a> (simtime_t_cref start, simtime_t_cref end, const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a> exclude=NULL) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a RSSI-Mapping (or Noise-Strength-Mapping) for a <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>.  <a href="#a53eb943cea4604171a5c1cc4cdec4c20"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eece8bf532f92912ccbd0a3bc4d6fb0"></a><!-- doxytag: member="BaseDecider::sensitivity" ref="a5eece8bf532f92912ccbd0a3bc4d6fb0" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0">sensitivity</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensitivity value for receiving an AirFrame if it <code>&lt;= 0</code> then no sensitivity check will be done. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22e578e992fab5ab54fe5fcdf196d9e3"></a><!-- doxytag: member="BaseDecider::currentSignal" ref="a22e578e992fab5ab54fe5fcdf196d9e3" args="" -->
<a class="el" href="a00020.html#aa13822e21b4389a929359e581c4ec659">ReceivedSignal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the currently received AirFrame. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6cd60e58a8a557ed511f8193ced4f7e"></a><!-- doxytag: member="BaseDecider::currentChannelSenseRequest" ref="ac6cd60e58a8a557ed511f8193ced4f7e" args="" -->
<a class="el" href="a00020.html#a2b6737edc0aa4a9c90f2da7b090caf76">CSRInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e">currentChannelSenseRequest</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the currently running ChannelSenseRequest and its start-time <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33e7f02028e78116193d09d6cdbc987e"></a><!-- doxytag: member="BaseDecider::myIndex" ref="a33e7f02028e78116193d09d6cdbc987e" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#a33e7f02028e78116193d09d6cdbc987e">myIndex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">index for this Decider-instance given by Phy-Layer (mostly Host-index) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa22cd5156240713e37578172ba5557ce"></a><!-- doxytag: member="BaseDecider::debug" ref="aa22cd5156240713e37578172ba5557ce" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html#aa22cd5156240713e37578172ba5557ce">debug</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">toggles display of debugging messages <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Tracked statistic values.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6deaeeb4679fb1615e554e32351d0f8"></a><!-- doxytag: member="BaseDecider::nbFramesWithInterference" ref="af6deaeeb4679fb1615e554e32351d0f8" args="" -->
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>nbFramesWithInterference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4edc0767503b6e2fabf7d1c95769cf6c"></a><!-- doxytag: member="BaseDecider::nbFramesWithoutInterference" ref="a4edc0767503b6e2fabf7d1c95769cf6c" args="" -->
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>nbFramesWithoutInterference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe788d039da95bf14448d49100878056"></a><!-- doxytag: member="BaseDecider::nbFramesWithInterferencePartial" ref="abe788d039da95bf14448d49100878056" args="" -->
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>nbFramesWithInterferencePartial</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a116f303ff80bc33ee5567eef9c93e3c7"></a><!-- doxytag: member="BaseDecider::nbFramesWithoutInterferencePartial" ref="a116f303ff80bc33ee5567eef9c93e3c7" args="" -->
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>nbFramesWithoutInterferencePartial</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f9f4136734b77a716ddff10e4623b1c"></a><!-- doxytag: member="BaseDecider::nbFramesWithInterferenceDropped" ref="a0f9f4136734b77a716ddff10e4623b1c" args="" -->
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>nbFramesWithInterferenceDropped</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23234fcce39ae2b4615007ea59eef19c"></a><!-- doxytag: member="BaseDecider::nbFramesWithoutInterferenceDropped" ref="a23234fcce39ae2b4615007ea59eef19c" args="" -->
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>nbFramesWithoutInterferenceDropped</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Provides some base functionality for most common deciders. </p>
<p>Forwards the AirFrame from "processSignal" to "processNewSignal", "processSignalHeader" or "processSignalEnd" depending on the state for that AirFrame returned by "getSignalState".</p>
<p>Provides answering of ChannelSenseRequests (instantaneous and over time).</p>
<p>Subclasses should define when they consider the channel as idle by calling "setChannelIdleStatus" because <a class="el" href="a00020.html" title="Provides some base functionality for most common deciders.">BaseDecider</a> uses that to answer ChannelSenseRequests.</p>
<p>If a subclassing <a class="el" href="a00070.html" title="The basic Decider class.">Decider</a> only tries to receive one signal at a time it can use BaseDeciders "currentSignal" member which is a pair of the signal to receive and the state for that signal. The state is then used by BaseDeciders "getSignalState" to decide to which "process***" method to forward the signal. If a subclassing <a class="el" href="a00070.html" title="The basic Decider class.">Decider</a> needs states for more than one <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a> it has to store these states by itself and should probably override the "getSignalState" method. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a5f79c1bbb4b39c82164e0805e1eeb699"></a><!-- doxytag: member="BaseDecider::channel_sense_rssi_t" ref="a5f79c1bbb4b39c82164e0805e1eeb699" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;double, simtime_t&gt; <a class="el" href="a00020.html#a5f79c1bbb4b39c82164e0805e1eeb699">BaseDecider::channel_sense_rssi_t</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return type of <a class="el" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c" title="Calculates the RSSI value for the passed interval.">BaseDecider::calcChannelSenseRSSI</a> function. </p>
<p>The pair consists in first part the RSSI value and in second part the maximum reception time of all air frames in requested range. </p>

</div>
</div>
<a class="anchor" id="aa11a3ec12ab83f9223d7bf11279e6226"></a><!-- doxytag: member="BaseDecider::rssi_mapping_t" ref="aa11a3ec12ab83f9223d7bf11279e6226" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="a00136.html">Mapping</a>*, channel_sense_rssi_t::second_type&gt; <a class="el" href="a00020.html#aa11a3ec12ab83f9223d7bf11279e6226">BaseDecider::rssi_mapping_t</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return type of <a class="el" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20" title="Calculates a RSSI-Mapping (or Noise-Strength-Mapping) for a Signal.">BaseDecider::calculateRSSIMapping</a> function. </p>
<p>The pair consists in first part the RSSI map pointer and in second part the maximum reception time of all air frames in requested range. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a7232c10b806ef074db6b1452664cc4a2"></a><!-- doxytag: member="BaseDecider::BaseDeciderControlKinds" ref="a7232c10b806ef074db6b1452664cc4a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00020.html#a7232c10b806ef074db6b1452664cc4a2">BaseDecider::BaseDeciderControlKinds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The kinds of ControlMessages this <a class="el" href="a00070.html" title="The basic Decider class.">Decider</a> sends. </p>
<p>Sub-classing decider should begin their own kind enumeration at the value of "LAST_BASE_DECIDER_CONTROL_KIND". </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7232c10b806ef074db6b1452664cc4a2ab80ab87167f9836332d1d5678f6aab64"></a><!-- doxytag: member="PACKET_DROPPED" ref="a7232c10b806ef074db6b1452664cc4a2ab80ab87167f9836332d1d5678f6aab64" args="" -->PACKET_DROPPED</em>&nbsp;</td><td>
<p>The phy has recognized a bit error in the packet. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7232c10b806ef074db6b1452664cc4a2a1944cc67bf3f0c98342e3975bd05021c"></a><!-- doxytag: member="LAST_BASE_DECIDER_CONTROL_KIND" ref="a7232c10b806ef074db6b1452664cc4a2a1944cc67bf3f0c98342e3975bd05021c" args="" -->LAST_BASE_DECIDER_CONTROL_KIND</em>&nbsp;</td><td>
<p>Sub-classing decider should begin their own kinds at this value. </p>
</td></tr>
</table>
</dd>
</dl>
<div class="fragment"><pre class="fragment">                               {
    <a class="code" href="a00020.html#a7232c10b806ef074db6b1452664cc4a2ab80ab87167f9836332d1d5678f6aab64" title="The phy has recognized a bit error in the packet.">PACKET_DROPPED</a> = 22100,
    <a class="code" href="a00020.html#a7232c10b806ef074db6b1452664cc4a2a1944cc67bf3f0c98342e3975bd05021c" title="Sub-classing decider should begin their own kinds at this value.">LAST_BASE_DECIDER_CONTROL_KIND</a>
  };
</pre></div>
</div>
</div>
<a class="anchor" id="a66b8c7b730a6169202fdb36263b74aaa"></a><!-- doxytag: member="BaseDecider::eSignalState" ref="a66b8c7b730a6169202fdb36263b74aaa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">BaseDecider::eSignalState</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The current state of processing for a signal. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31"></a><!-- doxytag: member="NEW" ref="a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" args="" -->NEW</em>&nbsp;</td><td>
<p><a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a> is received the first time. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6"></a><!-- doxytag: member="EXPECT_HEADER" ref="a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6" args="" -->EXPECT_HEADER</em>&nbsp;</td><td>
<p>Waiting for the header of the signal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a66b8c7b730a6169202fdb36263b74aaaa5539b8e545c0676dab0b0efb80dfeeac"></a><!-- doxytag: member="EXPECT_END" ref="a66b8c7b730a6169202fdb36263b74aaaa5539b8e545c0676dab0b0efb80dfeeac" args="" -->EXPECT_END</em>&nbsp;</td><td>
<p>Waiting for the end of the signal. </p>
</td></tr>
</table>
</dd>
</dl>
<div class="fragment"><pre class="fragment">                    {
    <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>,
    <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6" title="Waiting for the header of the signal.">EXPECT_HEADER</a>,
    <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa5539b8e545c0676dab0b0efb80dfeeac" title="Waiting for the end of the signal.">EXPECT_END</a>,
  };
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acff4618fa7a9c2e9abf257e60e487de2"></a><!-- doxytag: member="BaseDecider::BaseDecider" ref="acff4618fa7a9c2e9abf257e60e487de2" args="(DeciderToPhyInterface *phy, double sensitivity, int myIndex, bool debug)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseDecider::BaseDecider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00079.html">DeciderToPhyInterface</a> *&#160;</td>
          <td class="paramname"><em>phy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sensitivity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the decider with the passed values. </p>
<p>Needs a pointer to its physical layer, the sensitivity, the index of the host and the debug flag. </p>
<div class="fragment"><pre class="fragment">    : <a class="code" href="a00070.html#aa17a9e339525c92d6e4139872c037016" title="Copy constructor is not allowed.">Decider</a>(phy)
    , nbFramesWithInterference(0)
    , nbFramesWithoutInterference(0)
    , nbFramesWithInterferencePartial(0)
    , nbFramesWithoutInterferencePartial(0)
    , nbFramesWithInterferenceDropped(0)
    , nbFramesWithoutInterferenceDropped(0)
    , <a class="code" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0" title="Sensitivity value for receiving an AirFrame if it &lt;= 0 then no sensitivity check will be done...">sensitivity</a>(<a class="code" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0" title="Sensitivity value for receiving an AirFrame if it &lt;= 0 then no sensitivity check will be done...">sensitivity</a>)
    , <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>(NULL, <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>)
    , <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>()
    , <a class="code" href="a00020.html#a33e7f02028e78116193d09d6cdbc987e" title="index for this Decider-instance given by Phy-Layer (mostly Host-index)">myIndex</a>(<a class="code" href="a00020.html#a33e7f02028e78116193d09d6cdbc987e" title="index for this Decider-instance given by Phy-Layer (mostly Host-index)">myIndex</a>)
    , <a class="code" href="a00020.html#aa22cd5156240713e37578172ba5557ce" title="toggles display of debugging messages">debug</a>(<a class="code" href="a00020.html#aa22cd5156240713e37578172ba5557ce" title="toggles display of debugging messages">debug</a>)
  {
    <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.clear();
  }
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab8e925001d1f8630338c50f8ec10bb0d"></a><!-- doxytag: member="BaseDecider::answerCSR" ref="ab8e925001d1f8630338c50f8ec10bb0d" args="(CSRInfo &amp;requestInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BaseDecider::answerCSR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a2b6737edc0aa4a9c90f2da7b090caf76">CSRInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>requestInfo</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Answers the ChannelSenseRequest (CSR) from the passed CSRInfo. </p>
<p>Calculates the rssi value and the channel idle state and sends the CSR together with the result back to the mac layer. </p>

<p>Reimplemented in <a class="el" href="a00203.html#aa7e33361b328274b04ff7bd2d6206e6d">SNRThresholdDecider</a>.</p>

<p>References <a class="el" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c">calcChannelSenseRSSI()</a>, <a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a>, <a class="el" href="a00079.html#afdcd74839d4a7c6ea34062c8e409220d">DeciderToPhyInterface::getSimTime()</a>, <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>, and <a class="el" href="a00079.html#a319e413b963f03ff218b0d0024fb66b9">DeciderToPhyInterface::sendControlMsgToMac()</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#add7242168c4bb521c6335f3de590e4b0">channelStateChanged()</a>, <a class="el" href="a00020.html#a1dba383c238fba606279ef483b435f78">handleNewSenseRequest()</a>, and <a class="el" href="a00020.html#a2f175306cc0ae9d2805bc050315a47d8">handleSenseRequestEnd()</a>.</p>
<div class="fragment"><pre class="fragment">{
    simtime_t            now            = <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#afdcd74839d4a7c6ea34062c8e409220d" title="Returns the current simulation time.">getSimTime</a>(); <span class="comment">// maybe better requestInfo.getAnswerTime()</span>
    <a class="code" href="a00020.html#a5f79c1bbb4b39c82164e0805e1eeb699" title="Return type of BaseDecider::calcChannelSenseRSSI function.">channel_sense_rssi_t</a> pairRssiMaxEnd = <a class="code" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c" title="Calculates the RSSI value for the passed interval.">calcChannelSenseRSSI</a>(requestInfo.getSenseStart(), now);

  <span class="comment">// put the sensing-result to the request and</span>
  <span class="comment">// send it to the Mac-Layer as Control-message (via Interface)</span>
  requestInfo.getRequest()-&gt;setResult( <a class="code" href="a00044.html" title="Provides information about the current state of the channel:">ChannelState</a>(!<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.isProcessing() &amp;&amp; (!bUseNewSense || pairRssiMaxEnd.second &lt;= now), pairRssiMaxEnd.first) );

    deciderEV &lt;&lt; <span class="stringliteral">&quot;answerCSR: channel_sense_rssi_t(&quot;</span> &lt;&lt; pairRssiMaxEnd.first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; pairRssiMaxEnd.second &lt;&lt; <span class="stringliteral">&quot;)@[&quot;</span> &lt;&lt; SIMTIME_STR(requestInfo.getSenseStart()) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; SIMTIME_STR(now) &lt;&lt; <span class="stringliteral">&quot;] ChannelState(&quot;</span> &lt;&lt; requestInfo.getRequest()-&gt;getResult().isIdle() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; requestInfo.getRequest()-&gt;getResult().getRSSI() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;

  <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#a319e413b963f03ff218b0d0024fb66b9" title="Called by the Decider to send a control message to the MACLayer.">sendControlMsgToMac</a>(requestInfo.getRequest());
  requestInfo.clear();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac7a2b437d463db0f1f8f85d5a9685c2c"></a><!-- doxytag: member="BaseDecider::calcChannelSenseRSSI" ref="ac7a2b437d463db0f1f8f85d5a9685c2c" args="(simtime_t_cref start, simtime_t_cref end) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html#a5f79c1bbb4b39c82164e0805e1eeb699">BaseDecider::channel_sense_rssi_t</a> BaseDecider::calcChannelSenseRSSI </td>
          <td>(</td>
          <td class="paramtype">simtime_t_cref&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t_cref&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the RSSI value for the passed interval. </p>
<p>This method is called by <a class="el" href="a00020.html" title="Provides some base functionality for most common deciders.">BaseDecider</a> when it answers a ChannelSenseRequest or calculates the channel state. Can be overridden by sub classing Deciders.</p>
<p>Default implementation returns the maximum RSSI value inside the passed interval. </p>

<p>Reimplemented in <a class="el" href="a00071.html#a0be01ad3cb9198b895cc7a0424a26609">Decider80211</a>.</p>

<p>References <a class="el" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20">calculateRSSIMapping()</a>, <a class="el" href="a00138.html#afbe1a1e1d2becd66d2c0d5a8ac42b478">MappingUtils::findMax()</a>, and <a class="el" href="a00013.html#a8523627cdc70492e5e0935b9a3a78cc4">Argument::MappedZero</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#ab8e925001d1f8630338c50f8ec10bb0d">answerCSR()</a>, <a class="el" href="a00020.html#a1807c7256b577fe24cdd8e9c839f1d20">channelChanged()</a>, <a class="el" href="a00074.html#a0543e527dd0cad7b247b0fd0d55e038a">Decider802154Narrow::createResult()</a>, and <a class="el" href="a00020.html#a35e3f8f4e683747fbec1618ee1608982">getChannelState()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                {
    <a class="code" href="a00020.html#aa11a3ec12ab83f9223d7bf11279e6226" title="Return type of BaseDecider::calculateRSSIMapping function.">rssi_mapping_t</a> pairMapMaxEnd = <a class="code" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20" title="Calculates a RSSI-Mapping (or Noise-Strength-Mapping) for a Signal.">calculateRSSIMapping</a>(start, end);

  <span class="comment">// the sensed RSSI-value is the maximum value between (and including) the interval-borders</span>
  Mapping::argument_value_t rssi = <a class="code" href="a00138.html#afbe1a1e1d2becd66d2c0d5a8ac42b478" title="Iterates over the passed mapping and returns value at the key entry with the highest value...">MappingUtils::findMax</a>(*pairMapMaxEnd.first, <a class="code" href="a00013.html" title="Defines an argument for a mapping.">Argument</a>(start), <a class="code" href="a00013.html" title="Defines an argument for a mapping.">Argument</a>(end), <a class="code" href="a00013.html#a8523627cdc70492e5e0935b9a3a78cc4" title="Zero value of a Argument value.">Argument::MappedZero</a> <span class="comment">/* the value if no maximum will be found */</span>);

  <span class="keyword">delete</span> pairMapMaxEnd.first;
  <span class="keywordflow">return</span> std::make_pair(rssi, pairMapMaxEnd.second);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a53eb943cea4604171a5c1cc4cdec4c20"></a><!-- doxytag: member="BaseDecider::calculateRSSIMapping" ref="a53eb943cea4604171a5c1cc4cdec4c20" args="(simtime_t_cref start, simtime_t_cref end, const airframe_ptr_t exclude=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html#aa11a3ec12ab83f9223d7bf11279e6226">BaseDecider::rssi_mapping_t</a> BaseDecider::calculateRSSIMapping </td>
          <td>(</td>
          <td class="paramtype">simtime_t_cref&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t_cref&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>exclude</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates a RSSI-Mapping (or Noise-Strength-Mapping) for a <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>. </p>
<p>This method can be used to calculate a RSSI-Mapping in case the parameter exclude is omitted OR to calculate a Noise-Strength-Mapping in case the AirFrame of the received <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a> is passed as parameter exclude.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The mapping and the maximum reception end of all air frames in rang [start,end]. </dd></dl>

<p>References <a class="el" href="a00138.html#a0c61c76ba04339162563339b23bf42e9">MappingUtils::createMapping()</a>, <a class="el" href="a00020.html#a0310d4013043026404832008d40d48b9">getChannelInfo()</a>, <a class="el" href="a00192.html#a78255d9a9f6c3bffb72a51ce48e2fbb9">Signal::getReceivingPower()</a>, <a class="el" href="a00192.html#a2875223239e124d85949e1116cc12ae9">Signal::getReceptionEnd()</a>, <a class="el" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2">Signal::getReceptionStart()</a>, <a class="el" href="a00079.html#a2c55926187883df5bc322c947d317534">DeciderToPhyInterface::getThermalNoise()</a>, <a class="el" href="a00013.html#a8523627cdc70492e5e0935b9a3a78cc4">Argument::MappedZero</a>, <a class="el" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51">Decider::notAgain</a>, <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>, and <a class="el" href="a00086.html#abf3b99a319deca6efc123ec52d77d867">DimensionSet::timeDomain</a>.</p>

<p>Referenced by <a class="el" href="a00071.html#a0be01ad3cb9198b895cc7a0424a26609">Decider80211::calcChannelSenseRSSI()</a>, <a class="el" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c">calcChannelSenseRSSI()</a>, <a class="el" href="a00020.html#aea9e98c3a9752bcf08e42742b01d2fe3">calculateSnrMapping()</a>, and <a class="el" href="a00203.html#ae38586c5255f37cfe67aa1bdec283dde">SNRThresholdDecider::canAnswerCSR()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span>(exclude) {
    deciderEV &lt;&lt; <span class="stringliteral">&quot;Creating RSSI map for range [&quot;</span> &lt;&lt; SIMTIME_STR(start) &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; SIMTIME_STR(end) &lt;&lt; <span class="stringliteral">&quot;] excluding AirFrame with id &quot;</span> &lt;&lt; exclude-&gt;getId() &lt;&lt; endl;
  }
  <span class="keywordflow">else</span> {
    deciderEV &lt;&lt; <span class="stringliteral">&quot;Creating RSSI map for range [&quot;</span> &lt;&lt; SIMTIME_STR(start) &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; SIMTIME_STR(end) &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; endl;
  }

  <a class="code" href="a00070.html#a6baab300e0bec90320dfe956c2d15a57" title="Defines what an AirFrameVector shall be here.">AirFrameVector</a> airFrames;
  simtime_t      MaxReceptionEnd = <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;

  <span class="comment">// collect all AirFrames that intersect with [start, end]</span>
  <a class="code" href="a00020.html#a0310d4013043026404832008d40d48b9" title="Collects the AirFrame on the channel during the passed interval.">getChannelInfo</a>(start, end, airFrames);

  <span class="comment">// create an empty mapping</span>
  <a class="code" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a>* resultMap = <a class="code" href="a00138.html#a0c61c76ba04339162563339b23bf42e9" title="Returns an appropriate changeable Mapping with the specified domain and the specified interpolation m...">MappingUtils::createMapping</a>(<a class="code" href="a00013.html#a8523627cdc70492e5e0935b9a3a78cc4" title="Zero value of a Argument value.">Argument::MappedZero</a>, <a class="code" href="a00086.html#abf3b99a319deca6efc123ec52d77d867" title="Shortcut to a DimensionSet which only contains time.">DimensionSet::timeDomain</a>);

  <span class="comment">//add thermal noise</span>
  <a class="code" href="a00058.html" title="Represents a not changeable mapping (mathematical function) from domain with at least the time to a A...">ConstMapping</a>* thermalNoise = <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#a2c55926187883df5bc322c947d317534" title="Returns a Mapping which defines the thermal noise in the passed time frame (in mW).">getThermalNoise</a>(start, end);
  <span class="keywordflow">if</span>(thermalNoise) {
    <a class="code" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a>* tmp = resultMap;
    resultMap = MappingUtils::add(*resultMap, *thermalNoise);
    <span class="keyword">delete</span> tmp;
  }

  <span class="comment">// otherwise, iterate over all AirFrames (except exclude)</span>
  <span class="comment">// and sum up their receiving-power-mappings</span>
  <span class="keywordflow">for</span> (AirFrameVector::const_iterator it = airFrames.begin(); it != airFrames.end(); ++it) {
    <span class="comment">// the vector should not contain pointers to 0</span>
    assert (*it != 0);

        simtime_t ReceptionEnd = (*it)-&gt;getSignal().getReceptionEnd();
        <span class="keywordflow">if</span> (ReceptionEnd &gt; MaxReceptionEnd) {
            MaxReceptionEnd = ReceptionEnd;
        }
    <span class="comment">// if iterator points to exclude (that includes the default-case &#39;exclude == 0&#39;)</span>
    <span class="comment">// then skip this AirFrame</span>
    <span class="keywordflow">if</span> ( *it == exclude ) {
      <span class="keywordflow">if</span> (thermalNoise &amp;&amp; exclude) {
        <span class="comment">// suggested by David Eckhoff:</span>
        <span class="comment">// Instead of ignoring the want-to-receive AirFrame when</span>
        <span class="comment">// building up the NoiseMap i add the thermalNoise for the time and</span>
        <span class="comment">// frequencies of this airframe. There&#39;s probably a better way to do it but</span>
        <span class="comment">// i did it like this:</span>
        <span class="keyword">const</span> <a class="code" href="a00058.html" title="Represents a not changeable mapping (mathematical function) from domain with at least the time to a A...">ConstMapping</a> *<span class="keyword">const</span> recvPowerMap = (*it)-&gt;getSignal().getReceivingPower();

        <span class="keywordflow">if</span> (recvPowerMap) {
                    deciderEV &lt;&lt; <span class="stringliteral">&quot;Adding mapping of Airframe with ID &quot;</span> &lt;&lt; (*it)-&gt;getId()
                              &lt;&lt; <span class="stringliteral">&quot;. Starts at &quot;</span>  &lt;&lt; SIMTIME_STR((*it)-&gt;getSignal().getReceptionStart())
                              &lt;&lt; <span class="stringliteral">&quot; and ends at &quot;</span> &lt;&lt; SIMTIME_STR((*it)-&gt;getSignal().getReceptionEnd()) &lt;&lt; endl;

          <a class="code" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a>* rcvPowerPlusThermalNoise = MappingUtils::add(      *recvPowerMap,             *thermalNoise );
          <a class="code" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a>* resultMapTmp             = MappingUtils::subtract( *rcvPowerPlusThermalNoise, *recvPowerMap );
          <a class="code" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a>* resultMapNew             = MappingUtils::add(      *resultMap,                *resultMapTmp );

          <span class="keyword">delete</span> rcvPowerPlusThermalNoise;
          <span class="keyword">delete</span> resultMapTmp;

          <span class="keyword">delete</span> resultMap;
          resultMap    = resultMapNew;
          resultMapNew = NULL;
        }
      }
      <span class="keywordflow">continue</span>;
    }

    <span class="comment">// otherwise get the Signal and its receiving-power-mapping</span>
    <a class="code" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>&amp; signal = (*it)-&gt;getSignal();

    <span class="comment">// backup pointer to result map</span>
    <span class="comment">// Mapping* resultMapOld = resultMap;</span>

    <span class="comment">// add the Signal&#39;s receiving-power-mapping to resultMap in [start, end],</span>
    <span class="comment">// the operation Mapping::add returns a pointer to a new Mapping</span>

    <span class="keyword">const</span> <a class="code" href="a00058.html" title="Represents a not changeable mapping (mathematical function) from domain with at least the time to a A...">ConstMapping</a> *<span class="keyword">const</span> recvPowerMap = signal.<a class="code" href="a00192.html#a78255d9a9f6c3bffb72a51ce48e2fbb9" title="Calculates and returns the receiving power of this Signal. Ownership of the returned mapping belongs ...">getReceivingPower</a>();
    assert(recvPowerMap);

    deciderEV &lt;&lt; <span class="stringliteral">&quot;Adding mapping of Airframe with ID &quot;</span> &lt;&lt; (*it)-&gt;getId()
              &lt;&lt; <span class="stringliteral">&quot;. Starts at &quot;</span>  &lt;&lt; SIMTIME_STR(signal.<a class="code" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2" title="Returns the point in time when the receiving of the Signal started at the receiver module...">getReceptionStart</a>())
              &lt;&lt; <span class="stringliteral">&quot; and ends at &quot;</span> &lt;&lt; SIMTIME_STR(signal.<a class="code" href="a00192.html#a2875223239e124d85949e1116cc12ae9" title="Returns the point in time when the receiving of the Signal ended at the receiver module. Already includes the propagation delay.">getReceptionEnd</a>()) &lt;&lt; endl;

    <a class="code" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a>* resultMapNew = MappingUtils::add( *recvPowerMap, *resultMap, <a class="code" href="a00013.html#a8523627cdc70492e5e0935b9a3a78cc4" title="Zero value of a Argument value.">Argument::MappedZero</a> );

    <span class="comment">// discard old mapping</span>
    <span class="keyword">delete</span> resultMap;
    resultMap    = resultMapNew;
    resultMapNew = NULL;
  }

  <span class="keywordflow">return</span> std::make_pair(resultMap, MaxReceptionEnd);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aea9e98c3a9752bcf08e42742b01d2fe3"></a><!-- doxytag: member="BaseDecider::calculateSnrMapping" ref="aea9e98c3a9752bcf08e42742b01d2fe3" args="(const airframe_ptr_t frame) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00136.html">Mapping</a> * BaseDecider::calculateSnrMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates a SNR-Mapping for a <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>. </p>
<p>A Noise-Strength-Mapping is calculated (by using the "calculateRSSIMapping()"-method) for the time-interval of the <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a> and the Signal-Strength-Mapping is divided by the Noise-Strength-Mapping.</p>
<p>Note: 'divided' means here the special element-wise operation on mappings. </p>

<p>References <a class="el" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20">calculateRSSIMapping()</a>, <a class="el" href="a00192.html#a78255d9a9f6c3bffb72a51ce48e2fbb9">Signal::getReceivingPower()</a>, <a class="el" href="a00192.html#a2875223239e124d85949e1116cc12ae9">Signal::getReceptionEnd()</a>, <a class="el" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2">Signal::getReceptionStart()</a>, and <a class="el" href="a00013.html#a8523627cdc70492e5e0935b9a3a78cc4">Argument::MappedZero</a>.</p>

<p>Referenced by <a class="el" href="a00203.html#ac75875c691493cd4c69a01f3aeb6cd22">SNRThresholdDecider::createResult()</a>, <a class="el" href="a00074.html#a0543e527dd0cad7b247b0fd0d55e038a">Decider802154Narrow::createResult()</a>, and <a class="el" href="a00071.html#ae8d8435cae6ef92cc9bf8008e0bb56e4">Decider80211::createResult()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">/* calculate Noise-Strength-Mapping */</span>
  <span class="keyword">const</span> <a class="code" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>&amp; signal = frame-&gt;getSignal();

  simtime_t     start = signal.<a class="code" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2" title="Returns the point in time when the receiving of the Signal started at the receiver module...">getReceptionStart</a>();
  simtime_t     end   = signal.<a class="code" href="a00192.html#a2875223239e124d85949e1116cc12ae9" title="Returns the point in time when the receiving of the Signal ended at the receiver module. Already includes the propagation delay.">getReceptionEnd</a>();

  <a class="code" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a>*                  noiseMap     = <a class="code" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20" title="Calculates a RSSI-Mapping (or Noise-Strength-Mapping) for a Signal.">calculateRSSIMapping</a>(start, end, frame).first;
  <span class="keyword">const</span> <a class="code" href="a00058.html" title="Represents a not changeable mapping (mathematical function) from domain with at least the time to a A...">ConstMapping</a> *<span class="keyword">const</span> recvPowerMap = signal.<a class="code" href="a00192.html#a78255d9a9f6c3bffb72a51ce48e2fbb9" title="Calculates and returns the receiving power of this Signal. Ownership of the returned mapping belongs ...">getReceivingPower</a>();
    assert(noiseMap);
  assert(recvPowerMap);

  <span class="comment">//TODO: handle noise of zero (must not devide with zero!)</span>
  <a class="code" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a>* snrMap = MappingUtils::divide( *recvPowerMap, *noiseMap, <a class="code" href="a00013.html#a8523627cdc70492e5e0935b9a3a78cc4" title="Zero value of a Argument value.">Argument::MappedZero</a> );

  <span class="keyword">delete</span> noiseMap;
  noiseMap = NULL;

  <span class="keywordflow">return</span> snrMap;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1807c7256b577fe24cdd8e9c839f1d20"></a><!-- doxytag: member="BaseDecider::channelChanged" ref="a1807c7256b577fe24cdd8e9c839f1d20" args="(int newChannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BaseDecider::channelChanged </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newChannel</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by phy layer to indicate that the channel this radio currently listens to has changed. </p>
<p>Sub-classing deciders which support multiple channels should override this method to handle the effects of channel changes on ongoing receptions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newChannel</td><td>The new channel the radio has changed to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="a00070.html#ae4da9f61748737c85000dd64e07b66a0">Decider</a>.</p>

<p>Reimplemented in <a class="el" href="a00073.html#ab688642bf38bd6fe6e3a2cc82c48f4d6">Decider80211MultiChannel</a>.</p>

<p>References <a class="el" href="a00215.html#a5e4a7bdf0f72b5d8f887a24c4c47af97">BaseDecider::tProcessingSignal::busyUntilTime</a>, <a class="el" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c">calcChannelSenseRSSI()</a>, <a class="el" href="a00020.html#add7242168c4bb521c6335f3de590e4b0">channelStateChanged()</a>, <a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a>, <a class="el" href="a00079.html#afdcd74839d4a7c6ea34062c8e409220d">DeciderToPhyInterface::getSimTime()</a>, and <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>.</p>
<div class="fragment"><pre class="fragment">                                               {
    <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.clear();

    simtime_t            now            = <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#afdcd74839d4a7c6ea34062c8e409220d" title="Returns the current simulation time.">getSimTime</a>();
    <a class="code" href="a00020.html#a5f79c1bbb4b39c82164e0805e1eeb699" title="Return type of BaseDecider::calcChannelSenseRSSI function.">channel_sense_rssi_t</a> pairRssiMaxEnd = <a class="code" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c" title="Calculates the RSSI value for the passed interval.">calcChannelSenseRSSI</a>(now, now);

    <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a5e4a7bdf0f72b5d8f887a24c4c47af97" title="the next idle time point">busyUntilTime</a> = pairRssiMaxEnd.second;

    <a class="code" href="a00020.html#add7242168c4bb521c6335f3de590e4b0" title="Checks if the changed channel state enables us to answer any ongoing ChannelSenseRequests.">channelStateChanged</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="add7242168c4bb521c6335f3de590e4b0"></a><!-- doxytag: member="BaseDecider::channelStateChanged" ref="add7242168c4bb521c6335f3de590e4b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BaseDecider::channelStateChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the changed channel state enables us to answer any ongoing ChannelSenseRequests. </p>
<p>This method is ment to update only an already ongoing ChannelSenseRequests it can't handle a new one. </p>

<p>Reimplemented in <a class="el" href="a00072.html#a6de7b8cd714e30cfdd2126c8b5c1ca59">Decider80211Battery</a>.</p>

<p>References <a class="el" href="a00020.html#ab8e925001d1f8630338c50f8ec10bb0d">answerCSR()</a>, <a class="el" href="a00020.html#ab6c1c16f5d0f3c18dd029aa9cac256a6">canAnswerCSR()</a>, <a class="el" href="a00079.html#af85151048dba05ec27e378000fd95403">DeciderToPhyInterface::cancelScheduledMessage()</a>, <a class="el" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e">currentChannelSenseRequest</a>, <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>, and <a class="el" href="a00079.html#a223fb24be9268abba32e90181fa248b9">DeciderToPhyInterface::rescheduleMessage()</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#a1807c7256b577fe24cdd8e9c839f1d20">channelChanged()</a>, and <a class="el" href="a00020.html#a066c6bb5c11795e973d14157ea3a9c64">processSignal()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span>(!<a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getRequest())
    <span class="keywordflow">return</span>;

  <span class="comment">//check if the point in time when we can answer the request has changed</span>
  simtime_t canAnswerAt = <a class="code" href="a00020.html#ab6c1c16f5d0f3c18dd029aa9cac256a6" title="Returns point in time when the ChannelSenseRequest of the passed CSRInfo can be answered (e...">canAnswerCSR</a>(<a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>);

  <span class="comment">//check if answer time has changed</span>
  <span class="keywordflow">if</span>(canAnswerAt != <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getAnswerTime()) {
    <span class="comment">//can we answer it now?</span>
    <span class="keywordflow">if</span>(canAnswerAt &lt;= phy-&gt;getSimTime()) {
      <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#af85151048dba05ec27e378000fd95403" title="Tells the PhyLayer to cancel a scheduled message (AirFrame or ControlMessage).">cancelScheduledMessage</a>(<a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getRequest());
      <a class="code" href="a00020.html#ab8e925001d1f8630338c50f8ec10bb0d" title="Answers the ChannelSenseRequest (CSR) from the passed CSRInfo.">answerCSR</a>(<a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>);
    } <span class="keywordflow">else</span> {
            <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.setAnswerTime( canAnswerAt );
      <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#a223fb24be9268abba32e90181fa248b9" title="Tells the PhyLayer to reschedule a message (AirFrame or ControlMessage).">rescheduleMessage</a>( <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getRequest()
                            , <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getAnswerTime());
    }
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac6ef3a4cf1b91bcec788b540d61bfeba"></a><!-- doxytag: member="BaseDecider::createResult" ref="ac6ef3a4cf1b91bcec788b540d61bfeba" args="(const airframe_ptr_t frame) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00075.html">DeciderResult</a> * BaseDecider::createResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates the <a class="el" href="a00075.html" title="A class to represent the result of a processed packet (that is not noise) by the Decider.">DeciderResult</a> from frame. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The processed frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result for frame. </dd></dl>

<p>Reimplemented in <a class="el" href="a00080.html#ac3ab3f2532249d7784907f0b3cb601a6">DeciderUWBIRED</a>, <a class="el" href="a00071.html#ae8d8435cae6ef92cc9bf8008e0bb56e4">Decider80211</a>, <a class="el" href="a00074.html#a0543e527dd0cad7b247b0fd0d55e038a">Decider802154Narrow</a>, <a class="el" href="a00203.html#ac75875c691493cd4c69a01f3aeb6cd22">SNRThresholdDecider</a>, and <a class="el" href="a00073.html#a43d8e040f2971e4793878b19ca614d0f">Decider80211MultiChannel</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#a6ff53fb85a926f2d6bdf8dd9164ee0c7">processSignalEnd()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00075.html" title="A class to represent the result of a processed packet (that is not noise) by the Decider.">DeciderResult</a>(!frame-&gt;hasBitError());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0310d4013043026404832008d40d48b9"></a><!-- doxytag: member="BaseDecider::getChannelInfo" ref="a0310d4013043026404832008d40d48b9" args="(simtime_t_cref start, simtime_t_cref end, AirFrameVector &amp;out) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BaseDecider::getChannelInfo </td>
          <td>(</td>
          <td class="paramtype">simtime_t_cref&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t_cref&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00070.html#a6baab300e0bec90320dfe956c2d15a57">AirFrameVector</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Collects the AirFrame on the channel during the passed interval. </p>
<p>Forwards to DeciderToPhyInterfaces "getChannelInfo" method. Subclassing deciders can override this method to filter the returned AirFrames for their own criteria.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start of the interval to collect AirFrames from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the interval to collect AirFrames from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The output vector in which to put the AirFrames. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00079.html#a304e09a4309820bc45450f8a5fcfcb34">DeciderToPhyInterface::getChannelInfo()</a>, and <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20">calculateRSSIMapping()</a>, and <a class="el" href="a00074.html#a0543e527dd0cad7b247b0fd0d55e038a">Decider802154Narrow::createResult()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#a304e09a4309820bc45450f8a5fcfcb34" title="Fills the passed AirFrameVector with all air frames that intersect with the time interval [from...">getChannelInfo</a>(start, end, out);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a35e3f8f4e683747fbec1618ee1608982"></a><!-- doxytag: member="BaseDecider::getChannelState" ref="a35e3f8f4e683747fbec1618ee1608982" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00044.html">ChannelState</a> BaseDecider::getChannelState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function that returns information about the channel state. </p>
<p>It is an alternative for the MACLayer in order to obtain information immediately (in contrast to sending a ChannelSenseRequest, i.e. sending a cMessage over the OMNeT-control-channel) </p>

<p>Reimplemented from <a class="el" href="a00070.html#aa9f0dcd955639fa2c16233f4654a82bc">Decider</a>.</p>

<p>Reimplemented in <a class="el" href="a00203.html#aa777b8c29fabf14d30d03972fed515d0">SNRThresholdDecider</a>, and <a class="el" href="a00080.html#afa82a8d2406cc58c21057561bc7af138">DeciderUWBIRED</a>.</p>

<p>References <a class="el" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c">calcChannelSenseRSSI()</a>, <a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a>, <a class="el" href="a00079.html#afdcd74839d4a7c6ea34062c8e409220d">DeciderToPhyInterface::getSimTime()</a>, and <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>.</p>
<div class="fragment"><pre class="fragment">                                                {

  simtime_t            now            = <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#afdcd74839d4a7c6ea34062c8e409220d" title="Returns the current simulation time.">getSimTime</a>();
  <a class="code" href="a00020.html#a5f79c1bbb4b39c82164e0805e1eeb699" title="Return type of BaseDecider::calcChannelSenseRSSI function.">channel_sense_rssi_t</a> pairRssiMaxEnd = <a class="code" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c" title="Calculates the RSSI value for the passed interval.">calcChannelSenseRSSI</a>(now, now);

  <span class="keywordflow">return</span> <a class="code" href="a00044.html" title="Provides information about the current state of the channel:">ChannelState</a>(!<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.isProcessing() &amp;&amp; (!bUseNewSense || pairRssiMaxEnd.second &lt;= now), pairRssiMaxEnd.first);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9f433fe8b7693074d3121320e50c85e3"></a><!-- doxytag: member="BaseDecider::getFrameReceivingPower" ref="a9f433fe8b7693074d3121320e50c85e3" args="(airframe_ptr_t frame) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BaseDecider::getFrameReceivingPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the receive power of given frame. </p>
<p>Default implementation use only the arrival time point for signal receive power calculation. </p>

<p>Reimplemented in <a class="el" href="a00071.html#a81e91e9aa6db0ebad8d19ae8b3bc037a">Decider80211</a>.</p>

<p>References <a class="el" href="a00192.html#a78255d9a9f6c3bffb72a51ce48e2fbb9">Signal::getReceivingPower()</a>, <a class="el" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2">Signal::getReceptionStart()</a>, and <a class="el" href="a00138.html#a31183e79401391df3e2d250846ae8d0e">MappingUtils::post()</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#aa2a5b719b17153ecd9decb7dce98a0d1">processNewSignal()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                     {
  <span class="comment">// get the receiving power of the Signal at start-time</span>
  <span class="comment">//Note: We assume the transmission power is represented by a rectangular function</span>
  <span class="comment">//which discontinuities (at start and end of the signal) are represented</span>
  <span class="comment">//by two key entries with different values very close to each other (see</span>
  <span class="comment">//MappingUtils &quot;addDiscontinuity&quot; method for details). This means</span>
  <span class="comment">//the transmission- and therefore also the receiving-power-mapping is still zero</span>
  <span class="comment">//at the exact start of the signal and not till one time step after the start its</span>
  <span class="comment">//at its actual transmission(/receiving) power.</span>
  <span class="comment">//Therefore we use MappingUtils &quot;post&quot;-method to ask for the receiving power</span>
  <span class="comment">//at the correct position.</span>
  <a class="code" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>&amp;   signal         = frame-&gt;getSignal();
  simtime_t receivingStart = <a class="code" href="a00138.html#a31183e79401391df3e2d250846ae8d0e" title="returns the closest value of simtime after passed values">MappingUtils::post</a>(signal.<a class="code" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2" title="Returns the point in time when the receiving of the Signal started at the receiver module...">getReceptionStart</a>());

  <span class="keywordflow">return</span> signal.<a class="code" href="a00192.html#a78255d9a9f6c3bffb72a51ce48e2fbb9" title="Calculates and returns the receiving power of this Signal. Ownership of the returned mapping belongs ...">getReceivingPower</a>()-&gt;getValue(<a class="code" href="a00013.html" title="Defines an argument for a mapping.">Argument</a>(receivingStart));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5e45eb03d1a7f3653385181236714f21"></a><!-- doxytag: member="BaseDecider::getNextSignalHandleTime" ref="a5e45eb03d1a7f3653385181236714f21" args="(const airframe_ptr_t frame) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t BaseDecider::getNextSignalHandleTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next handle time for scheduler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The current frame which is in processing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next scheduler handle time. </dd></dl>

<p>Reimplemented in <a class="el" href="a00080.html#a675e00e69e4b9627552bbd8cc2da4cd5">DeciderUWBIRED</a>.</p>

<p>References <a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a>, <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6">EXPECT_HEADER</a>, <a class="el" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691">BaseDecider::tProcessingSignal::first</a>, <a class="el" href="a00192.html#afcfa26a0f384f475a019446b33c7458d">Signal::getBitrate()</a>, <a class="el" href="a00079.html#a7579990df34650e82125a1b91105ae15">DeciderToPhyInterface::getPhyHeaderLength()</a>, <a class="el" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2">Signal::getReceptionStart()</a>, <a class="el" href="a00020.html#a53c0ec4fdf4f47e54fc1e8c757a18f91">getSignalState()</a>, <a class="el" href="a00058.html#afabbd15bb8f50e45901f99633d0a47c9">ConstMapping::getValue()</a>, <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31">NEW</a>, <a class="el" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51">Decider::notAgain</a>, <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>, and <a class="el" href="a00138.html#a2cf7c04c0adea7f6e9fe49101b0197c3">MappingUtils::pre()</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#aa2a5b719b17153ecd9decb7dce98a0d1">processNewSignal()</a>, and <a class="el" href="a00020.html#a6ff53fb85a926f2d6bdf8dd9164ee0c7">processSignalEnd()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                               {
    <span class="keywordflow">if</span> (frame != <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691" title="second_type is the second bound type">first</a>)
        <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;
    <span class="keywordflow">switch</span>(<a class="code" href="a00020.html#a53c0ec4fdf4f47e54fc1e8c757a18f91" title="Returns the SignalState for the passed AirFrame.">getSignalState</a>(frame)) {
        <span class="keywordflow">case</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>:           <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>; <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6" title="Waiting for the header of the signal.">EXPECT_HEADER</a>: {
            <span class="comment">// we expect the header first, so we must return the time after header is arrived</span>
            <span class="keyword">const</span> <a class="code" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>&amp; FrameSignal = frame-&gt;getSignal();
            <span class="keywordtype">double</span>        dBitrate    = FrameSignal.<a class="code" href="a00192.html#afcfa26a0f384f475a019446b33c7458d" title="Returns the function representing the bitrate of the signal.">getBitrate</a>()-&gt;<a class="code" href="a00058.html#afabbd15bb8f50e45901f99633d0a47c9" title="Returns the value of this Mapping at the position specified by the passed Argument.">getValue</a>(<a class="code" href="a00013.html" title="Defines an argument for a mapping.">Argument</a>(FrameSignal.<a class="code" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2" title="Returns the point in time when the receiving of the Signal started at the receiver module...">getReceptionStart</a>()));

            assert(dBitrate != 0.0);

            <span class="comment">// frame-&gt;getBitLength() should store the phy-header-length (@see BasePhyLayer::encapsMsg).</span>
            <span class="comment">//simtime_t    tHandleTime  = FrameSignal.getReceptionStart() + (static_cast&lt;double&gt;(frame-&gt;getBitLength()) / dBitrate);</span>
            simtime_t    tHandleTime  = FrameSignal.<a class="code" href="a00192.html#a7c4710243cf87caf7dfc9f313e2619b2" title="Returns the point in time when the receiving of the Signal started at the receiver module...">getReceptionStart</a>() + (<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(<a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#a7579990df34650e82125a1b91105ae15" title="Returns the length of the phy header in bits.">getPhyHeaderLength</a>()) / dBitrate);
            <span class="keywordflow">if</span> (tHandleTime &lt; frame-&gt;getSignal().getReceptionEnd())
                <span class="keywordflow">return</span> tHandleTime;
            <span class="keywordflow">return</span> <a class="code" href="a00138.html#a2cf7c04c0adea7f6e9fe49101b0197c3" title="returns the closest value of simtime before passed value">MappingUtils::pre</a>(frame-&gt;getSignal().getReceptionEnd());
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> frame-&gt;getSignal().getReceptionEnd();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4a8ddbaf158b593d4aabeac39c1d36ad"></a><!-- doxytag: member="BaseDecider::getNextSignalState" ref="a4a8ddbaf158b593d4aabeac39c1d36ad" args="(eSignalState CurState) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">eSignalState</a> BaseDecider::getNextSignalState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">eSignalState</a>&#160;</td>
          <td class="paramname"><em>CurState</em></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next signal state (END, HEADER, NEW). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">CurState</td><td>The current signal state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next signal state. </dd></dl>

<p>Reimplemented in <a class="el" href="a00080.html#a8f260e182096aa6e810512b06046af35">DeciderUWBIRED</a>, and <a class="el" href="a00074.html#a122afffb9bc9be41d382a81a5b222603">Decider802154Narrow</a>.</p>

<p>Referenced by <a class="el" href="a00074.html#a122afffb9bc9be41d382a81a5b222603">Decider802154Narrow::getNextSignalState()</a>, <a class="el" href="a00080.html#a8f260e182096aa6e810512b06046af35">DeciderUWBIRED::getNextSignalState()</a>, and <a class="el" href="a00020.html#aa2a5b719b17153ecd9decb7dce98a0d1">processNewSignal()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                       {
      <span class="keywordflow">switch</span>(CurState) {
            <span class="keywordflow">case</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>:           <span class="keywordflow">return</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa5539b8e545c0676dab0b0efb80dfeeac" title="Waiting for the end of the signal.">EXPECT_END</a>; <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6" title="Waiting for the header of the signal.">EXPECT_HEADER</a>: <span class="keywordflow">return</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa5539b8e545c0676dab0b0efb80dfeeac" title="Waiting for the end of the signal.">EXPECT_END</a>; <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>:            <span class="keywordflow">return</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>;        <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a53c0ec4fdf4f47e54fc1e8c757a18f91"></a><!-- doxytag: member="BaseDecider::getSignalState" ref="a53c0ec4fdf4f47e54fc1e8c757a18f91" args="(const airframe_ptr_t frame) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaa">BaseDecider::eSignalState</a> BaseDecider::getSignalState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the SignalState for the passed AirFrame. </p>
<p>The default implementation checks if the passed AirFrame is the "currentSignal" and returns its state or if not "NEW". </p>

<p>References <a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a>, <a class="el" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691">BaseDecider::tProcessingSignal::first</a>, <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31">NEW</a>, and <a class="el" href="a00215.html#adc1fa9d47e6115bd743a57b97c722c36">BaseDecider::tProcessingSignal::second</a>.</p>

<p>Referenced by <a class="el" href="a00080.html#a675e00e69e4b9627552bbd8cc2da4cd5">DeciderUWBIRED::getNextSignalHandleTime()</a>, <a class="el" href="a00020.html#a5e45eb03d1a7f3653385181236714f21">getNextSignalHandleTime()</a>, and <a class="el" href="a00020.html#a066c6bb5c11795e973d14157ea3a9c64">processSignal()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                    {
  <span class="keywordflow">if</span> (frame == <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691" title="second_type is the second bound type">first</a>)
    <span class="keywordflow">return</span> <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#adc1fa9d47e6115bd743a57b97c722c36" title="first is a copy of the first object">second</a>;

  <span class="keywordflow">return</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afd31e5a65d1798d329ace9bdbec25d64"></a><!-- doxytag: member="BaseDecider::handleChannelSenseRequest" ref="afd31e5a65d1798d329ace9bdbec25d64" args="(ChannelSenseRequest *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t BaseDecider::handleChannelSenseRequest </td>
          <td>(</td>
          <td class="paramtype">ChannelSenseRequest *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is called by the <a class="el" href="a00173.html" title="Provides initialisation for several AnalogueModels and Deciders from modules directory.">PhyLayer</a> to hand over a ChannelSenseRequest. </p>
<p>The MACLayer is able to send a ChannelSenseRequest to the <a class="el" href="a00173.html" title="Provides initialisation for several AnalogueModels and Deciders from modules directory.">PhyLayer</a> that calls this function with it and is returned a time point when to re-call this function with the specific ChannelSenseRequest.</p>
<p>The <a class="el" href="a00070.html" title="The basic Decider class.">Decider</a> puts the result (<a class="el" href="a00044.html" title="Provides information about the current state of the channel:">ChannelState</a>) to the ChannelSenseRequest and "answers" by calling the "sendControlMsg"-function on the <a class="el" href="a00079.html" title="This class is the interface for a Decider to the BasePhyLayer.">DeciderToPhyInterface</a>, i.e. telling the <a class="el" href="a00173.html" title="Provides initialisation for several AnalogueModels and Deciders from modules directory.">PhyLayer</a> to send it back. </p>

<p>Reimplemented from <a class="el" href="a00070.html#a93548ff29f4d880ed488785509dd4dd9">Decider</a>.</p>

<p>References <a class="el" href="a00020.html#ab6c1c16f5d0f3c18dd029aa9cac256a6">canAnswerCSR()</a>, <a class="el" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e">currentChannelSenseRequest</a>, <a class="el" href="a00079.html#afdcd74839d4a7c6ea34062c8e409220d">DeciderToPhyInterface::getSimTime()</a>, <a class="el" href="a00020.html#a1dba383c238fba606279ef483b435f78">handleNewSenseRequest()</a>, <a class="el" href="a00020.html#a2f175306cc0ae9d2805bc050315a47d8">handleSenseRequestEnd()</a>, <a class="el" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51">Decider::notAgain</a>, and <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>.</p>
<div class="fragment"><pre class="fragment">{

  assert(request);

  <span class="keywordflow">if</span> (<a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getRequest() == NULL) {
    <span class="keywordflow">return</span> <a class="code" href="a00020.html#a1dba383c238fba606279ef483b435f78" title="Handles a new incoming ChannelSenseRequest and returns the next (or latest) time to handle the reques...">handleNewSenseRequest</a>(request);
  }

  <span class="keywordflow">if</span> (<a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getRequest() != request) {
    opp_error(<span class="stringliteral">&quot;Got a new ChannelSenseRequest while already handling another one!&quot;</span>);
    <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;
  }
  simtime_t now = <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#afdcd74839d4a7c6ea34062c8e409220d" title="Returns the current simulation time.">getSimTime</a>();

  <span class="keywordflow">if</span>(now &gt;= <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getAnswerTime()) {
      simtime_t canAnswerAt = <a class="code" href="a00020.html#ab6c1c16f5d0f3c18dd029aa9cac256a6" title="Returns point in time when the ChannelSenseRequest of the passed CSRInfo can be answered (e...">canAnswerCSR</a>(<a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>);

      <span class="keywordflow">if</span> (canAnswerAt &gt; now) {
          <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.setAnswerTime( canAnswerAt );
          <span class="keywordflow">return</span> <a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>.getAnswerTime();
      }
  }
  <a class="code" href="a00020.html#a2f175306cc0ae9d2805bc050315a47d8" title="Handles the timeout or end of a ChannelSenseRequest by calculating the ChannelState and returning the...">handleSenseRequestEnd</a>(<a class="code" href="a00020.html#ac6cd60e58a8a557ed511f8193ced4f7e" title="pointer to the currently running ChannelSenseRequest and its start-time">currentChannelSenseRequest</a>);
  <span class="comment">// say that we don&#39;t want to have it again</span>
  <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2f175306cc0ae9d2805bc050315a47d8"></a><!-- doxytag: member="BaseDecider::handleSenseRequestEnd" ref="a2f175306cc0ae9d2805bc050315a47d8" args="(CSRInfo &amp;requestInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BaseDecider::handleSenseRequestEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00020.html#a2b6737edc0aa4a9c90f2da7b090caf76">CSRInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>requestInfo</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handles the timeout or end of a ChannelSenseRequest by calculating the <a class="el" href="a00044.html" title="Provides information about the current state of the channel:">ChannelState</a> and returning the request to the mac layer. </p>
<p>If this handler is reached the decider has to be able to answer the request. Either because the timeout is reached or because the channel state changed accordingly. </p>

<p>References <a class="el" href="a00020.html#ab8e925001d1f8630338c50f8ec10bb0d">answerCSR()</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#afd31e5a65d1798d329ace9bdbec25d64">handleChannelSenseRequest()</a>.</p>
<div class="fragment"><pre class="fragment">                                                            {
  <span class="comment">//assert(canAnswerCSR(requestInfo) &lt;= phy-&gt;getSimTime());</span>
  <a class="code" href="a00020.html#ab8e925001d1f8630338c50f8ec10bb0d" title="Answers the ChannelSenseRequest (CSR) from the passed CSRInfo.">answerCSR</a>(requestInfo);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa2a5b719b17153ecd9decb7dce98a0d1"></a><!-- doxytag: member="BaseDecider::processNewSignal" ref="aa2a5b719b17153ecd9decb7dce98a0d1" args="(airframe_ptr_t frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t BaseDecider::processNewSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes a new <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>. Returns the time it wants to handle the signal again. </p>
<p>Default implementation checks if the signals receiving power is above the sensitivity of the radio and we are not already trying to receive another AirFrame. If thats the case it waits for the end of the signal. </p>

<p>References <a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a>, <a class="el" href="a00020.html#a9f433fe8b7693074d3121320e50c85e3">getFrameReceivingPower()</a>, <a class="el" href="a00020.html#a5e45eb03d1a7f3653385181236714f21">getNextSignalHandleTime()</a>, <a class="el" href="a00020.html#a4a8ddbaf158b593d4aabeac39c1d36ad">getNextSignalState()</a>, <a class="el" href="a00079.html#a7832acf422e9ae79fbf91af927ca9e44">DeciderToPhyInterface::isRadioInRX()</a>, <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31">NEW</a>, <a class="el" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51">Decider::notAgain</a>, <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>, and <a class="el" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0">sensitivity</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#a066c6bb5c11795e973d14157ea3a9c64">processSignal()</a>.</p>
<div class="fragment"><pre class="fragment">                                                            {

  <span class="keywordflow">if</span>(<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.isProcessing()) {
    deciderEV &lt;&lt; <span class="stringliteral">&quot;Already receiving another AirFrame!&quot;</span> &lt;&lt; endl;
    <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.interferenceWith(frame);
    <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;
  }

  <span class="keyword">const</span> <span class="keywordtype">bool</span>   bCheckSensitivity = <a class="code" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0" title="Sensitivity value for receiving an AirFrame if it &lt;= 0 then no sensitivity check will be done...">sensitivity</a> &gt; 0.;
  <span class="keyword">const</span> <span class="keywordtype">double</span> recvPower         = bCheckSensitivity ? <a class="code" href="a00020.html#a9f433fe8b7693074d3121320e50c85e3" title="Calculates the receive power of given frame.">getFrameReceivingPower</a>(frame) : 0.;

  <span class="comment">// check whether signal is strong enough to receive</span>
  <span class="keywordflow">if</span> ( bCheckSensitivity &amp;&amp; recvPower &lt; <a class="code" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0" title="Sensitivity value for receiving an AirFrame if it &lt;= 0 then no sensitivity check will be done...">sensitivity</a> ) {
    deciderEV &lt;&lt; <span class="stringliteral">&quot;Signal is to weak (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="stringliteral">&quot; &lt; &quot;</span> &lt;&lt; <a class="code" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0" title="Sensitivity value for receiving an AirFrame if it &lt;= 0 then no sensitivity check will be done...">sensitivity</a>
        &lt;&lt; <span class="stringliteral">&quot;) -&gt; do not receive.&quot;</span> &lt;&lt; endl;
    <span class="comment">// Signal too weak, we can&#39;t receive it, tell PhyLayer that we don&#39;t want it again</span>
    <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bCheckSensitivity &amp;&amp; recvPower != 0) {
    <span class="comment">// Signal is strong enough, receive this Signal and schedule it</span>
    deciderEV &lt;&lt; <span class="stringliteral">&quot;Signal is strong enough (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="stringliteral">&quot; &gt; &quot;</span> &lt;&lt; <a class="code" href="a00020.html#a5eece8bf532f92912ccbd0a3bc4d6fb0" title="Sensitivity value for receiving an AirFrame if it &lt;= 0 then no sensitivity check will be done...">sensitivity</a>
        &lt;&lt; <span class="stringliteral">&quot;) -&gt; Trying to receive AirFrame.&quot;</span> &lt;&lt; endl;
  }

  <span class="keywordflow">if</span> (!<a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#a7832acf422e9ae79fbf91af927ca9e44" title="Returns the true if the radio is in RX state.">isRadioInRX</a>()) {
        frame-&gt;setBitError(<span class="keyword">true</span>);
        deciderEV &lt;&lt; <span class="stringliteral">&quot;AirFrame with ID &quot;</span> &lt;&lt; frame-&gt;getId() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; recvPower &lt;&lt; <span class="stringliteral">&quot;) received, while not receiving. Setting BitErrors to true.&quot;</span> &lt;&lt; endl;
  }

  <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.startProcessing(frame, <a class="code" href="a00020.html#a4a8ddbaf158b593d4aabeac39c1d36ad" title="Returns the next signal state (END, HEADER, NEW).">getNextSignalState</a>(<a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>));

  <span class="keywordflow">return</span> <a class="code" href="a00020.html#a5e45eb03d1a7f3653385181236714f21" title="Returns the next handle time for scheduler.">getNextSignalHandleTime</a>(frame);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a066c6bb5c11795e973d14157ea3a9c64"></a><!-- doxytag: member="BaseDecider::processSignal" ref="a066c6bb5c11795e973d14157ea3a9c64" args="(airframe_ptr_t frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t BaseDecider::processSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes an AirFrame given by the <a class="el" href="a00173.html" title="Provides initialisation for several AnalogueModels and Deciders from modules directory.">PhyLayer</a>. </p>
<p>Returns the time point when the decider wants to be given the AirFrame again. </p>

<p>Reimplemented from <a class="el" href="a00070.html#a130dabc37fec0d579d010de251995558">Decider</a>.</p>

<p>References <a class="el" href="a00020.html#add7242168c4bb521c6335f3de590e4b0">channelStateChanged()</a>, <a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a>, <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa5539b8e545c0676dab0b0efb80dfeeac">EXPECT_END</a>, <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6">EXPECT_HEADER</a>, <a class="el" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691">BaseDecider::tProcessingSignal::first</a>, <a class="el" href="a00079.html#a5c8df09fc0711587b07e2ac5d8412554">DeciderToPhyInterface::getCurrentRadioChannel()</a>, <a class="el" href="a00215.html#a5b698123b757c9e2024f83de10db37a7">BaseDecider::tProcessingSignal::getInterferenceCnt()</a>, <a class="el" href="a00079.html#ae6cc727e6364c8a55fb735d18f93faa8">DeciderToPhyInterface::getNbRadioChannels()</a>, <a class="el" href="a00020.html#a53c0ec4fdf4f47e54fc1e8c757a18f91">getSignalState()</a>, <a class="el" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31">NEW</a>, <a class="el" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51">Decider::notAgain</a>, <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>, <a class="el" href="a00020.html#aa2a5b719b17153ecd9decb7dce98a0d1">processNewSignal()</a>, <a class="el" href="a00020.html#a6ff53fb85a926f2d6bdf8dd9164ee0c7">processSignalEnd()</a>, <a class="el" href="a00020.html#ab53849078ba0481ea80a8926bdedd5f0">processSignalHeader()</a>, and <a class="el" href="a00020.html#aacce0cd3c123c63be6acfd773f936910">processUnknownSignal()</a>.</p>
<div class="fragment"><pre class="fragment">                                                         {
  deciderEV &lt;&lt; <span class="stringliteral">&quot;Processing AirFrame with ID &quot;</span> &lt;&lt; frame-&gt;getId() &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; endl;

  simtime_t HandleAgain = <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;

    <span class="keywordflow">if</span>(<a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#ae6cc727e6364c8a55fb735d18f93faa8" title="Returns the number of channels available in radio.">getNbRadioChannels</a>() &gt; 1 &amp;&amp; frame-&gt;getChannel() != <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#a5c8df09fc0711587b07e2ac5d8412554" title="Returns the channel currently used by the radio.">getCurrentRadioChannel</a>()) {
        <span class="comment">// we cannot synchronize on a frame on another channel.</span>
        <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;
    }

    <span class="keywordtype">bool</span> bInteruptedProcessing = <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.isProcessing();
    <span class="keywordtype">bool</span> bFinishProcessing     = <span class="keyword">false</span>;

  <span class="keywordflow">switch</span>(<a class="code" href="a00020.html#a53c0ec4fdf4f47e54fc1e8c757a18f91" title="Returns the SignalState for the passed AirFrame.">getSignalState</a>(frame)) {
        <span class="keywordflow">case</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa3276f47da7417662597b21ee3afa2d31" title="Signal is received the first time.">NEW</a>: {
            deciderEV &lt;&lt; <span class="stringliteral">&quot;... AirFrame processing as NewSignal...&quot;</span> &lt;&lt; endl;
            HandleAgain           = <a class="code" href="a00020.html#aa2a5b719b17153ecd9decb7dce98a0d1" title="Processes a new Signal. Returns the time it wants to handle the signal again.">processNewSignal</a>(frame);
            bInteruptedProcessing = bInteruptedProcessing &amp;&amp; !<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.isProcessing();
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaaf0a66719215a9be8335546666facaab6" title="Waiting for the header of the signal.">EXPECT_HEADER</a>: {
            deciderEV &lt;&lt; <span class="stringliteral">&quot;... AirFrame processing as SignalHeader...&quot;</span> &lt;&lt; endl;
            HandleAgain           = <a class="code" href="a00020.html#ab53849078ba0481ea80a8926bdedd5f0" title="Processes the end of the header of a received Signal.">processSignalHeader</a>(frame);
            bInteruptedProcessing = bInteruptedProcessing &amp;&amp; !<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.isProcessing();
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="a00020.html#a66b8c7b730a6169202fdb36263b74aaaa5539b8e545c0676dab0b0efb80dfeeac" title="Waiting for the end of the signal.">EXPECT_END</a>: {
            deciderEV &lt;&lt; <span class="stringliteral">&quot;... AirFrame processing as SignalEnd...&quot;</span> &lt;&lt; endl;
            bFinishProcessing     = frame == <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691" title="second_type is the second bound type">first</a>;
            HandleAgain           = <a class="code" href="a00020.html#a6ff53fb85a926f2d6bdf8dd9164ee0c7" title="Processes the end of a received Signal.">processSignalEnd</a>(frame);
            bFinishProcessing     = bFinishProcessing &amp;&amp; bInteruptedProcessing &amp;&amp; (HandleAgain &lt; SIMTIME_ZERO);
            bInteruptedProcessing = <span class="keyword">false</span>;
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
            deciderEV &lt;&lt; <span class="stringliteral">&quot;... AirFrame processing as UnknownSignal...&quot;</span> &lt;&lt; endl;
            bFinishProcessing     = frame == <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691" title="second_type is the second bound type">first</a>;
            HandleAgain           = <a class="code" href="a00020.html#aacce0cd3c123c63be6acfd773f936910" title="Processes any Signal for which no state could be found. (is an error case).">processUnknownSignal</a>(frame);
            bFinishProcessing     = bFinishProcessing &amp;&amp; bInteruptedProcessing &amp;&amp; (HandleAgain &lt; SIMTIME_ZERO);
            bInteruptedProcessing = <span class="keyword">false</span>;
        } <span class="keywordflow">break</span>;
  }

  <span class="keywordflow">if</span> (bFinishProcessing || bInteruptedProcessing) {
      <span class="keywordflow">if</span> (!bFinishProcessing &amp;&amp; bInteruptedProcessing) {
          <span class="keywordflow">if</span> (<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a5b698123b757c9e2024f83de10db37a7" title="Returns the current interference count (how many other frames are on air on processing).">getInterferenceCnt</a>() &gt; 0) {
              ++nbFramesWithInterferencePartial;
          }
          <span class="keywordflow">else</span> {
              ++nbFramesWithoutInterferencePartial;
          }
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bFinishProcessing) {
          <span class="keywordflow">if</span> (<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.isProcessing())
              <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.finishProcessing();
      }
  }

  <span class="comment">// following call is important for channel sense request</span>
  <span class="comment">// handling, in the past this call was done in the process...</span>
  <span class="comment">// methods, but it shall be called always on processSignal</span>
  <span class="comment">// messages</span>
  <a class="code" href="a00020.html#add7242168c4bb521c6335f3de590e4b0" title="Checks if the changed channel state enables us to answer any ongoing ChannelSenseRequests.">channelStateChanged</a>();

  <span class="keywordflow">return</span> HandleAgain;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ff53fb85a926f2d6bdf8dd9164ee0c7"></a><!-- doxytag: member="BaseDecider::processSignalEnd" ref="a6ff53fb85a926f2d6bdf8dd9164ee0c7" args="(airframe_ptr_t frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t BaseDecider::processSignalEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes the end of a received <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>. </p>
<p>Returns the time it wants to handle the signal again (most probably notAgain).</p>
<p>Default implementation just decides every signal as correct and passes it to the upper layer. </p>

<p>References <a class="el" href="a00020.html#ac6ef3a4cf1b91bcec788b540d61bfeba">createResult()</a>, <a class="el" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3">currentSignal</a>, <a class="el" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691">BaseDecider::tProcessingSignal::first</a>, <a class="el" href="a00215.html#a5b698123b757c9e2024f83de10db37a7">BaseDecider::tProcessingSignal::getInterferenceCnt()</a>, <a class="el" href="a00020.html#a5e45eb03d1a7f3653385181236714f21">getNextSignalHandleTime()</a>, <a class="el" href="a00075.html#aa0ff5bc718c64668cb1ce09c2c7dba80">DeciderResult::isSignalCorrect()</a>, <a class="el" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51">Decider::notAgain</a>, <a class="el" href="a00020.html#a7232c10b806ef074db6b1452664cc4a2ab80ab87167f9836332d1d5678f6aab64">PACKET_DROPPED</a>, <a class="el" href="a00070.html#ac0f72556cb799d883b4219cab58320bb">Decider::phy</a>, <a class="el" href="a00079.html#a319e413b963f03ff218b0d0024fb66b9">DeciderToPhyInterface::sendControlMsgToMac()</a>, <a class="el" href="a00079.html#ad81919dcafb2d568303e9ed362dafd93">DeciderToPhyInterface::sendUp()</a>, and <a class="el" href="a00177.html#a7d5a61c8f8a55edd3ea9e7d8195543ef">PhyToMacControlInfo::setControlInfo()</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#a066c6bb5c11795e973d14157ea3a9c64">processSignal()</a>.</p>
<div class="fragment"><pre class="fragment">                                                            {
    <span class="keywordflow">if</span> (frame != <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a9e1a097b36bb1ae3338001b8af83d691" title="second_type is the second bound type">first</a>)
        <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>; <span class="comment">// it is not the frame which we are processing</span>

  <a class="code" href="a00075.html" title="A class to represent the result of a processed packet (that is not noise) by the Decider.">DeciderResult</a>* pResult = <a class="code" href="a00020.html#ac6ef3a4cf1b91bcec788b540d61bfeba" title="Creates the DeciderResult from frame.">createResult</a>(frame);

  <span class="keywordflow">if</span> (pResult != NULL &amp;&amp; pResult-&gt;<a class="code" href="a00075.html#aa0ff5bc718c64668cb1ce09c2c7dba80" title="A Function that returns a very basic result about the Signal.">isSignalCorrect</a>() &amp;&amp; !frame-&gt;hasBitError()) {
        deciderEV &lt;&lt; <span class="stringliteral">&quot;AirFrame was received correctly, it is now handed to upper layer...&quot;</span> &lt;&lt; endl;
        <span class="comment">// go on with processing this AirFrame, send it to the Mac-Layer</span>
        <span class="keywordflow">if</span> (<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a5b698123b757c9e2024f83de10db37a7" title="Returns the current interference count (how many other frames are on air on processing).">getInterferenceCnt</a>() &gt; 0) {
            ++nbFramesWithInterference;
        }
        <span class="keywordflow">else</span> {
            ++nbFramesWithoutInterference;
        }
        <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#ad81919dcafb2d568303e9ed362dafd93" title="Called to send an AirFrame with DeciderResult to the MACLayer.">sendUp</a>(frame, pResult);
    }
  <span class="keywordflow">else</span> {
        deciderEV &lt;&lt; <span class="stringliteral">&quot;AirFrame was not received correctly, sending it as control message to upper layer&quot;</span> &lt;&lt; endl;
        cPacket* pMacPacket = frame-&gt;decapsulate();
        <span class="keywordflow">if</span> (<a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.<a class="code" href="a00215.html#a5b698123b757c9e2024f83de10db37a7" title="Returns the current interference count (how many other frames are on air on processing).">getInterferenceCnt</a>() &gt; 0) {
            ++nbFramesWithInterferenceDropped;
        }
        <span class="keywordflow">else</span> {
            ++nbFramesWithoutInterferenceDropped;
        }
        <span class="keywordflow">if</span> (pMacPacket) {
            pMacPacket-&gt;setName(<span class="stringliteral">&quot;ERROR&quot;</span>);
            pMacPacket-&gt;setKind(<a class="code" href="a00020.html#a7232c10b806ef074db6b1452664cc4a2ab80ab87167f9836332d1d5678f6aab64" title="The phy has recognized a bit error in the packet.">PACKET_DROPPED</a>);
            <span class="keywordflow">if</span> (pResult) {
                <a class="code" href="a00177.html#a7d5a61c8f8a55edd3ea9e7d8195543ef" title="Attaches a &quot;control info&quot; structure (object) to the message pMsg.">PhyToMacControlInfo::setControlInfo</a>(pMacPacket, pResult);
            }
            <a class="code" href="a00070.html#ac0f72556cb799d883b4219cab58320bb" title="A pointer to the physical layer of this Decider.">phy</a>-&gt;<a class="code" href="a00079.html#a319e413b963f03ff218b0d0024fb66b9" title="Called by the Decider to send a control message to the MACLayer.">sendControlMsgToMac</a>(pMacPacket);
        }
    }
    <a class="code" href="a00020.html#a22e578e992fab5ab54fe5fcdf196d9e3" title="Pointer to the currently received AirFrame.">currentSignal</a>.finishProcessing();

  <span class="keywordflow">return</span> <a class="code" href="a00020.html#a5e45eb03d1a7f3653385181236714f21" title="Returns the next handle time for scheduler.">getNextSignalHandleTime</a>(frame);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab53849078ba0481ea80a8926bdedd5f0"></a><!-- doxytag: member="BaseDecider::processSignalHeader" ref="ab53849078ba0481ea80a8926bdedd5f0" args="(airframe_ptr_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual simtime_t BaseDecider::processSignalHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#a8532046253d31801ffe4bc56b0d70850">airframe_ptr_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes the end of the header of a received <a class="el" href="a00192.html" title="The signal class stores the physical representation of the signal of an AirFrame.">Signal</a>. </p>
<p>Returns the time it wants to handle the signal again.</p>
<p>Default implementation does not handle signal headers. </p>

<p>Reimplemented in <a class="el" href="a00080.html#abe90eb371a8c63e71b6e550c93994b75">DeciderUWBIRED</a>, and <a class="el" href="a00074.html#a95c51ba6f01ba9055d0c91200d749d44">Decider802154Narrow</a>.</p>

<p>References <a class="el" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51">Decider::notAgain</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#a066c6bb5c11795e973d14157ea3a9c64">processSignal()</a>.</p>
<div class="fragment"><pre class="fragment">                                                          {
    opp_error(<span class="stringliteral">&quot;BaseDecider does not handle Signal headers!&quot;</span>);
    <span class="keywordflow">return</span> <a class="code" href="a00070.html#a7fbb5a5f14ae118e40d7db1903be6d51" title="simtime that tells the Phy-Layer not to pass an AirFrame again">notAgain</a>;
  }
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Projects/MiXiM/extsrc/mixim/src/base/phyLayer/<a class="el" href="a00283_source.html">BaseDecider.h</a></li>
<li>D:/Projects/MiXiM/extsrc/mixim/src/base/phyLayer/BaseDecider.cc</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00020.html">BaseDecider</a>      </li>

    <li class="footer">Generated on Tue Mar 5 2013 21:26:31 for MiXiM by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
