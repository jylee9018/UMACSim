<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: BMacLayer Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MiXiM
   &#160;<span id="projectnumber">2.3</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00035.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">BMacLayer Class Reference<div class="ingroups"><a class="el" href="a00509.html">macLayer - MAC layer modules</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="BMacLayer" --><!-- doxytag: inherits="BaseMacLayer" -->
<p>Implementation of B-MAC (called also Berkeley MAC, Low Power Listening or LPL).  
 <a href="a00035.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00424_source.html">BMacLayer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BMacLayer:</div>
<div class="dyncontent">
<div class="center"><img src="a00612.png" border="0" usemap="#BMacLayer_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for BMacLayer:</div>
<div class="dyncontent">
<div class="center"><img src="a00613.png" border="0" usemap="#BMacLayer_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00614.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacfdc6bca51f7097b58556fdf1744689"></a><!-- doxytag: member="BMacLayer::initialize" ref="aacfdc6bca51f7097b58556fdf1744689" args="(int)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#aacfdc6bca51f7097b58556fdf1744689">initialize</a> (int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of the module and some variables. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a977715453feffb03e242372808661828"></a><!-- doxytag: member="BMacLayer::finish" ref="a977715453feffb03e242372808661828" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a977715453feffb03e242372808661828">finish</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all dynamically allocated objects of the module. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ac16d3f8eda5c8d43c4a33a581aa4fbfb">handleLowerMsg</a> (cMessage *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle messages from lower layer.  <a href="#ac16d3f8eda5c8d43c4a33a581aa4fbfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a43c9f5377b89dd4cd4e4e48fb3e96107">handleUpperMsg</a> (cMessage *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle messages from upper layer.  <a href="#a43c9f5377b89dd4cd4e4e48fb3e96107"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a0d6b089a3e75932385bf38815b44b8bc">handleSelfMsg</a> (cMessage *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle self messages such as timers.  <a href="#a0d6b089a3e75932385bf38815b44b8bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a6b362134693ef8ab49abdea9a7d6dda1">handleLowerControl</a> (cMessage *msg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle control messages from lower layer.  <a href="#a6b362134693ef8ab49abdea9a7d6dda1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#aeed53f8e3ce2313f84d47dd7226f1a9f">States</a> { <br/>
&#160;&#160;<b>INIT</b>, 
<b>SLEEP</b>, 
<b>CCA</b>, 
<b>SEND_PREAMBLE</b>, 
<br/>
&#160;&#160;<b>WAIT_DATA</b>, 
<b>SEND_DATA</b>, 
<b>WAIT_TX_DATA_OVER</b>, 
<b>WAIT_ACK</b>, 
<br/>
&#160;&#160;<b>SEND_ACK</b>, 
<b>WAIT_ACK_TX</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MAC states.  <a href="a00035.html#aeed53f8e3ce2313f84d47dd7226f1a9f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a7d56487b9b46428d6c225ad59cf1e1cf">TYPES</a> { <br/>
&#160;&#160;<b>BMAC_PREAMBLE</b> =  191, 
<b>BMAC_DATA</b>, 
<b>BMAC_ACK</b>, 
<b>BMAC_RESEND_DATA</b>, 
<br/>
&#160;&#160;<b>BMAC_ACK_TIMEOUT</b>, 
<b>BMAC_START_BMAC</b>, 
<b>BMAC_WAKE_UP</b>, 
<b>BMAC_SEND_ACK</b>, 
<br/>
&#160;&#160;<b>BMAC_CCA_TIMEOUT</b>, 
<b>BMAC_ACK_TX_OVER</b>, 
<b>BMAC_SEND_PREAMBLE</b>, 
<b>BMAC_STOP_PREAMBLES</b>, 
<br/>
&#160;&#160;<b>BMAC_DATA_TX_OVER</b>, 
<b>BMAC_DATA_TIMEOUT</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of messages (self messages and packets) the node can process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ab86d33b96584c398e40eb6ee973ce3e9">BMAC_COLORS</a> { <br/>
&#160;&#160;<b>GREEN</b> =  1, 
<b>BLUE</b> =  2, 
<b>RED</b> =  3, 
<b>BLACK</b> =  4, 
<br/>
&#160;&#160;<b>YELLOW</b> =  5
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible colors of the node for animation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5858f009b2297135483e4c7d8cddabb"></a><!-- doxytag: member="BMacLayer::MacQueue" ref="af5858f009b2297135483e4c7d8cddabb" args="" -->
typedef std::list&lt; macpkt_ptr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MacQueue</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a727a243ed5bfe43d34452f310860fd74">changeDisplayColor</a> (<a class="el" href="a00035.html#ab86d33b96584c398e40eb6ee973ce3e9">BMAC_COLORS</a> color)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to change the color of the node.  <a href="#a727a243ed5bfe43d34452f310860fd74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f19dac6f5e7041c9b65a1e547763ffa"></a><!-- doxytag: member="BMacLayer::sendDataPacket" ref="a2f19dac6f5e7041c9b65a1e547763ffa" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a2f19dac6f5e7041c9b65a1e547763ffa">sendDataPacket</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to send the first packet in the queue. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#af2a4df90f60f2c5b93813b5424f7ee0f">sendMacAck</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to send an ACK.  <a href="#af2a4df90f60f2c5b93813b5424f7ee0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#afeb78e201913f491b8abb8416dd6eefc">sendPreamble</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to send one preamble.  <a href="#afeb78e201913f491b8abb8416dd6eefc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f0384e6e1a28a7d303ec5d6d2cc9dd4"></a><!-- doxytag: member="BMacLayer::attachSignal" ref="a5f0384e6e1a28a7d303ec5d6d2cc9dd4" args="(macpkt_ptr_t macPkt)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a5f0384e6e1a28a7d303ec5d6d2cc9dd4">attachSignal</a> (macpkt_ptr_t macPkt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to attach a signal to the packet. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#acff92f0d4ba44ee5035c0d3729729257">addToQueue</a> (cMessage *msg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to add a new packet from upper to the queue.  <a href="#acff92f0d4ba44ee5035c0d3729729257"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae34984aa9d79ca356e9d310cf7fe431e"></a><!-- doxytag: member="BMacLayer::macQueue" ref="ae34984aa9d79ca356e9d310cf7fe431e" args="" -->
MacQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e">macQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue to store packets from upper layer in case another packet is still waiting for transmission. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f547e9f97f0c07b692c32c4183c5411"></a><!-- doxytag: member="BMacLayer::macState" ref="a3f547e9f97f0c07b692c32c4183c5411" args="" -->
<a class="el" href="a00035.html#aeed53f8e3ce2313f84d47dd7226f1a9f">States</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411">macState</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of the protocol. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e2aa705eae24e7148f4bbe0471d3229"></a><!-- doxytag: member="BMacLayer::resend_data" ref="a1e2aa705eae24e7148f4bbe0471d3229" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>resend_data</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a145c410ec2d1eb9e3597b3200c26f0d2"></a><!-- doxytag: member="BMacLayer::ack_timeout" ref="a145c410ec2d1eb9e3597b3200c26f0d2" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>ack_timeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62d5d912d56ba740ea23f07dccd6fcbc"></a><!-- doxytag: member="BMacLayer::start_bmac" ref="a62d5d912d56ba740ea23f07dccd6fcbc" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>start_bmac</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6313438a0e18d8fddff825cef84d9195"></a><!-- doxytag: member="BMacLayer::wakeup" ref="a6313438a0e18d8fddff825cef84d9195" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>wakeup</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1198ad2c538df561f6fd1eb9199500bd"></a><!-- doxytag: member="BMacLayer::send_ack" ref="a1198ad2c538df561f6fd1eb9199500bd" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>send_ack</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac68eaf403ee572049cdd43847781d05c"></a><!-- doxytag: member="BMacLayer::cca_timeout" ref="ac68eaf403ee572049cdd43847781d05c" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>cca_timeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5119f45880b076605c50cccd3f29f61a"></a><!-- doxytag: member="BMacLayer::ack_tx_over" ref="a5119f45880b076605c50cccd3f29f61a" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>ack_tx_over</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace3db346970036d2d2c69a3f19711359"></a><!-- doxytag: member="BMacLayer::send_preamble" ref="ace3db346970036d2d2c69a3f19711359" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>send_preamble</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaabfc50cbcf1575c29c768cdf1907433"></a><!-- doxytag: member="BMacLayer::stop_preambles" ref="aaabfc50cbcf1575c29c768cdf1907433" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>stop_preambles</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cd83b341f6b776c3ceb053f8fe7cfea"></a><!-- doxytag: member="BMacLayer::data_tx_over" ref="a2cd83b341f6b776c3ceb053f8fe7cfea" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>data_tx_over</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac52679dd69998ee9e391355043be28dc"></a><!-- doxytag: member="BMacLayer::data_timeout" ref="ac52679dd69998ee9e391355043be28dc" args="" -->
cMessage *&#160;</td><td class="memItemRight" valign="bottom"><b>data_timeout</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a19e8ed9b796a93f8e0aeeaff22de83"></a><!-- doxytag: member="BMacLayer::droppedPacket" ref="a6a19e8ed9b796a93f8e0aeeaff22de83" args="" -->
<a class="el" href="a00088.html">DroppedPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a6a19e8ed9b796a93f8e0aeeaff22de83">droppedPacket</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect reasons for dropped packets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eb298197cc0eac3b5cd389b9dc4d88a"></a><!-- doxytag: member="BMacLayer::nicId" ref="a5eb298197cc0eac3b5cd389b9dc4d88a" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a5eb298197cc0eac3b5cd389b9dc4d88a">nicId</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">publish dropped packets nic wide <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd3669a9dfbb2bc04d64f91ae8755a68"></a><!-- doxytag: member="BMacLayer::queueLength" ref="acd3669a9dfbb2bc04d64f91ae8755a68" args="" -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#acd3669a9dfbb2bc04d64f91ae8755a68">queueLength</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of the queue. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a344d41bb6a3dd348f0b193a253a44e63">animation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Animate (colorize) the nodes.  <a href="#a344d41bb6a3dd348f0b193a253a44e63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad52c754e33e66f1811d4d0a52f748aea"></a><!-- doxytag: member="BMacLayer::slotDuration" ref="ad52c754e33e66f1811d4d0a52f748aea" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea">slotDuration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The duration of the slot in secs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30e8c5f8b0666509bec376dcc7dc057b"></a><!-- doxytag: member="BMacLayer::bitrate" ref="a30e8c5f8b0666509bec376dcc7dc057b" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a30e8c5f8b0666509bec376dcc7dc057b">bitrate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The bitrate of transmission. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6672d3d6469bf079cea9e9fc0430cfd7"></a><!-- doxytag: member="BMacLayer::checkInterval" ref="a6672d3d6469bf079cea9e9fc0430cfd7" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7">checkInterval</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The duration of CCA. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8507b0daed75036c14e6822cddb09832"></a><!-- doxytag: member="BMacLayer::txPower" ref="a8507b0daed75036c14e6822cddb09832" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a8507b0daed75036c14e6822cddb09832">txPower</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmission power of the node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac44f7816182a2431558f281628808dbd"></a><!-- doxytag: member="BMacLayer::useMacAcks" ref="ac44f7816182a2431558f281628808dbd" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ac44f7816182a2431558f281628808dbd">useMacAcks</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use MAC level acks or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac89bcf80f1642195df80253067ba92e5"></a><!-- doxytag: member="BMacLayer::maxTxAttempts" ref="ac89bcf80f1642195df80253067ba92e5" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ac89bcf80f1642195df80253067ba92e5">maxTxAttempts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum transmission attempts per data packet, when ACKs are used. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a94af09a9ad4145931583187c8cc793"></a><!-- doxytag: member="BMacLayer::stats" ref="a3a94af09a9ad4145931583187c8cc793" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a3a94af09a9ad4145931583187c8cc793">stats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather stats at the end of the simulation. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Different tracked statistics.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9946b0282bdb89f97ac77defb0f21f29"></a><!-- doxytag: member="BMacLayer::nbTxDataPackets" ref="a9946b0282bdb89f97ac77defb0f21f29" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>nbTxDataPackets</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3f1a45e3ed165116eb7e611abdb7c02"></a><!-- doxytag: member="BMacLayer::nbTxPreambles" ref="af3f1a45e3ed165116eb7e611abdb7c02" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>nbTxPreambles</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ae502acaea0c8f470983c9a56475694"></a><!-- doxytag: member="BMacLayer::nbRxDataPackets" ref="a0ae502acaea0c8f470983c9a56475694" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>nbRxDataPackets</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f43f96f806b0316f6d01c7f21c4f363"></a><!-- doxytag: member="BMacLayer::nbRxPreambles" ref="a7f43f96f806b0316f6d01c7f21c4f363" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>nbRxPreambles</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0276e15ee64fe3090a02b607af5a28fa"></a><!-- doxytag: member="BMacLayer::nbMissedAcks" ref="a0276e15ee64fe3090a02b607af5a28fa" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>nbMissedAcks</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a307308885949e74955ec033cbe395588"></a><!-- doxytag: member="BMacLayer::nbRecvdAcks" ref="a307308885949e74955ec033cbe395588" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>nbRecvdAcks</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac945ffe44db428a09d1b08fda495f18a"></a><!-- doxytag: member="BMacLayer::nbDroppedDataPackets" ref="ac945ffe44db428a09d1b08fda495f18a" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>nbDroppedDataPackets</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf00fd5e322a487ae4bc0b4764b6fcb3"></a><!-- doxytag: member="BMacLayer::nbTxAcks" ref="acf00fd5e322a487ae4bc0b4764b6fcb3" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>nbTxAcks</b></td></tr>
<tr><td colspan="2"><div class="groupHeader">Help variables for the acknowledgment process.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71676818c7ef0efe88e96d4cf9586570"></a><!-- doxytag: member="BMacLayer::lastDataPktSrcAddr" ref="a71676818c7ef0efe88e96d4cf9586570" args="" -->
<a class="el" href="a00117.html#aea56b60dcb5ae8c2bde465271daf7210">LAddress::L2Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lastDataPktSrcAddr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b37169e49e94f23f31cc66eb4427f60"></a><!-- doxytag: member="BMacLayer::lastDataPktDestAddr" ref="a7b37169e49e94f23f31cc66eb4427f60" args="" -->
<a class="el" href="a00117.html#aea56b60dcb5ae8c2bde465271daf7210">LAddress::L2Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lastDataPktDestAddr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d7ed556ad8e34b05eeeb71e56a1737e"></a><!-- doxytag: member="BMacLayer::txAttempts" ref="a6d7ed556ad8e34b05eeeb71e56a1737e" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>txAttempts</b></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d881bb7876eef8b5c6845fe0daf259a"></a><!-- doxytag: member="BMacLayer::BMacLayer" ref="a0d881bb7876eef8b5c6845fe0daf259a" args="(const BMacLayer &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#a0d881bb7876eef8b5c6845fe0daf259a">BMacLayer</a> (const <a class="el" href="a00035.html">BMacLayer</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is not allowed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab48b373b857f30e8ebae7f2793b84736"></a><!-- doxytag: member="BMacLayer::operator=" ref="ab48b373b857f30e8ebae7f2793b84736" args="(const BMacLayer &amp;)" -->
<a class="el" href="a00035.html">BMacLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html#ab48b373b857f30e8ebae7f2793b84736">operator=</a> (const <a class="el" href="a00035.html">BMacLayer</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator is not allowed. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementation of B-MAC (called also Berkeley MAC, Low Power Listening or LPL). </p>
<p>The protocol works as follows: each node is allowed to sleep for slotDuration. After waking up, it first checks the channel for ongoing transmissions. If a transmission is catched (a preamble is received), the node stays awake for at most slotDuration and waits for the actual data packet. If a node wants to send a packet, it first sends preambles for at least slotDuration, thus waking up all nodes in its transmission radius and then sends out the data packet. If a mac-level ack is required, then the receiver sends the ack immediately after receiving the packet (no preambles) and the sender waits for some time more before going back to sleep.</p>
<p>B-MAC is designed for low traffic, low power communication in WSN and is one of the most widely used protocols (e.g. it is part of TinyOS). The finite state machine of the protocol is given in the below figure:</p>
<div class="image">
<img src="BMACFSM.png" alt="BMACFSM.png"/>
<div class="caption">
B-MAC Layer - finite state machine</div></div>
<p> A paper describing this implementation can be found at: <a href="http://www.omnet-workshop.org/2011/uploads/slides/OMNeT_WS2011_S5_C1_Foerster.pdf">http://www.omnet-workshop.org/2011/uploads/slides/OMNeT_WS2011_S5_C1_Foerster.pdf</a></p>
<dl class="author"><dt><b>Author:</b></dt><dd>Anna Foerster </dd></dl>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="aeed53f8e3ce2313f84d47dd7226f1a9f"></a><!-- doxytag: member="BMacLayer::States" ref="aeed53f8e3ce2313f84d47dd7226f1a9f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00035.html#aeed53f8e3ce2313f84d47dd7226f1a9f">BMacLayer::States</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MAC states. </p>
<p>The MAC states help to keep track what the MAC is actually trying to do. INIT -- node has just started and its status is unclear SLEEP -- node sleeps, but accepts packets from the network layer CCA -- Clear Channel Assessment - MAC checks whether medium is busy SEND_PREAMBLE -- node sends preambles to wake up all nodes WAIT_DATA -- node has received at least one preamble from another node and wiats for the actual data packet SEND_DATA -- node has sent enough preambles and sends the actual data packet WAIT_TX_DATA_OVER -- node waits until the data packet sending is ready WAIT_ACK -- node has sent the data packet and waits for ack from the receiving node SEND_ACK -- node send an ACK back to the sender WAIT_ACK_TX -- node waits until the transmission of the ack packet is over </p>
<div class="fragment"><pre class="fragment">              {
    INIT, <span class="comment">//0</span>
    SLEEP,  <span class="comment">//1</span>
    CCA,  <span class="comment">//2</span>
    SEND_PREAMBLE,  <span class="comment">//3</span>
    WAIT_DATA,    <span class="comment">//4</span>
    SEND_DATA,    <span class="comment">//5</span>
    WAIT_TX_DATA_OVER,  <span class="comment">//6</span>
    WAIT_ACK,   <span class="comment">//7</span>
    SEND_ACK,   <span class="comment">//8</span>
    WAIT_ACK_TX   <span class="comment">//9</span>
    };
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acff92f0d4ba44ee5035c0d3729729257"></a><!-- doxytag: member="BMacLayer::addToQueue" ref="acff92f0d4ba44ee5035c0d3729729257" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BMacLayer::addToQueue </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to add a new packet from upper to the queue. </p>
<p>Encapsulates the received network-layer packet into a MacPkt and set all needed header fields. </p>

<p>References <a class="el" href="a00025.html#ad8ba02d92dd106da1d85192eb28250c0">BaseLayer::catDroppedPacketSignal</a>, <a class="el" href="a00035.html#a6a19e8ed9b796a93f8e0aeeaff22de83">droppedPacket</a>, <a class="el" href="a00026.html#a48135ffa21044a71d92149d5301f9deb">BaseMacLayer::getUpperDestinationFromControlInfo()</a>, <a class="el" href="a00026.html#a26ddb186455b73c8dc8b5698296804d2">BaseMacLayer::headerLength</a>, <a class="el" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e">macQueue</a>, <a class="el" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411">macState</a>, <a class="el" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2">BaseMacLayer::myMacAddr</a>, <a class="el" href="a00026.html#a49e0e548a6c20d002bd67afa7b76c483adebf9c77bbe6f19772866cccbef0fe4b">BaseMacLayer::PACKET_DROPPED</a>, <a class="el" href="a00035.html#acd3669a9dfbb2bc04d64f91ae8755a68">queueLength</a>, <a class="el" href="a00025.html#aa1190a06fb4dfb15d8ff001468335dc8">BaseLayer::sendControlUp()</a>, and <a class="el" href="a00088.html#aef3c55476a292fea6434cc1c4c27f822">DroppedPacket::setReason()</a>.</p>

<p>Referenced by <a class="el" href="a00035.html#a43c9f5377b89dd4cd4e4e48fb3e96107">handleUpperMsg()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &gt;= <a class="code" href="a00035.html#acd3669a9dfbb2bc04d64f91ae8755a68" title="The maximum length of the queue.">queueLength</a>) {
    <span class="comment">// queue is full, message has to be deleted</span>
    debugEV &lt;&lt; <span class="stringliteral">&quot;New packet arrived, but queue is FULL, so new packet is&quot;</span>
          <span class="stringliteral">&quot; deleted\n&quot;</span>;
    msg-&gt;setName(<span class="stringliteral">&quot;MAC ERROR&quot;</span>);
    msg-&gt;setKind(<a class="code" href="a00026.html#a49e0e548a6c20d002bd67afa7b76c483adebf9c77bbe6f19772866cccbef0fe4b">PACKET_DROPPED</a>);
    <a class="code" href="a00025.html#aa1190a06fb4dfb15d8ff001468335dc8" title="Sends a control message to an upper layer.">sendControlUp</a>(msg);
    <a class="code" href="a00035.html#a6a19e8ed9b796a93f8e0aeeaff22de83" title="Inspect reasons for dropped packets.">droppedPacket</a>.<a class="code" href="a00088.html#aef3c55476a292fea6434cc1c4c27f822" title="set the state of the radio">setReason</a>(DroppedPacket::QUEUE);
    emit(<a class="code" href="a00025.html#ad8ba02d92dd106da1d85192eb28250c0" title="Signal for dropped packets.">BaseLayer::catDroppedPacketSignal</a>, &amp;<a class="code" href="a00035.html#a6a19e8ed9b796a93f8e0aeeaff22de83" title="Inspect reasons for dropped packets.">droppedPacket</a>);
    nbDroppedDataPackets++;

    <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }

  macpkt_ptr_t macPkt = <span class="keyword">new</span> MacPkt(msg-&gt;getName());
  macPkt-&gt;setBitLength(<a class="code" href="a00026.html#a26ddb186455b73c8dc8b5698296804d2" title="Pointer to the arp module.">headerLength</a>);
  cObject *<span class="keyword">const</span> cInfo = msg-&gt;removeControlInfo();
  <span class="comment">//EV&lt;&lt;&quot;CSMA received a message from upper layer, name is &quot;</span>
  <span class="comment">//  &lt;&lt; msg-&gt;getName() &lt;&lt;&quot;, CInfo removed, mac addr=&quot;</span>
  <span class="comment">//  &lt;&lt; cInfo-&gt;getNextHopMac()&lt;&lt;endl;</span>
  macPkt-&gt;setDestAddr(<a class="code" href="a00026.html#a48135ffa21044a71d92149d5301f9deb" title="Extracts the MAC address from the &quot;control info&quot; structure (object).">getUpperDestinationFromControlInfo</a>(cInfo));
  <span class="keyword">delete</span> cInfo;
  macPkt-&gt;setSrcAddr(<a class="code" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2" title="MAC address.">myMacAddr</a>);

  assert(static_cast&lt;cPacket*&gt;(msg));
  macPkt-&gt;encapsulate(static_cast&lt;cPacket*&gt;(msg));

  <a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.push_back(macPkt);
  debugEV &lt;&lt; <span class="stringliteral">&quot;Max queue length: &quot;</span> &lt;&lt; <a class="code" href="a00035.html#acd3669a9dfbb2bc04d64f91ae8755a68" title="The maximum length of the queue.">queueLength</a> &lt;&lt; <span class="stringliteral">&quot;, packet put in queue&quot;</span>
        <span class="stringliteral">&quot;\n  queue size: &quot;</span> &lt;&lt; <a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &lt;&lt; <span class="stringliteral">&quot; macState: &quot;</span>
        &lt;&lt; <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> &lt;&lt; endl;
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a727a243ed5bfe43d34452f310860fd74"></a><!-- doxytag: member="BMacLayer::changeDisplayColor" ref="a727a243ed5bfe43d34452f310860fd74" args="(BMAC_COLORS color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BMacLayer::changeDisplayColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00035.html#ab86d33b96584c398e40eb6ee973ce3e9">BMAC_COLORS</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to change the color of the node. </p>
<p>Change the color of the node for animation purposes. </p>

<p>References <a class="el" href="a00035.html#a344d41bb6a3dd348f0b193a253a44e63">animation</a>, and <a class="el" href="a00027.html#aabf0226159b22b46e70031fd3bb3b1b2">BaseModule::findHost()</a>.</p>

<p>Referenced by <a class="el" href="a00035.html#a0d6b089a3e75932385bf38815b44b8bc">handleSelfMsg()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!<a class="code" href="a00035.html#a344d41bb6a3dd348f0b193a253a44e63" title="Animate (colorize) the nodes.">animation</a>)
    <span class="keywordflow">return</span>;
  cDisplayString&amp; dispStr = <a class="code" href="a00027.html#aabf0226159b22b46e70031fd3bb3b1b2" title="Function to get a pointer to the host module.">findHost</a>()-&gt;getDisplayString();
  <span class="comment">//b=40,40,rect,black,black,2&quot;</span>
  <span class="keywordflow">if</span> (color == GREEN)
    dispStr.setTagArg(<span class="stringliteral">&quot;b&quot;</span>, 3, <span class="stringliteral">&quot;green&quot;</span>);
    <span class="comment">//dispStr.parse(&quot;b=40,40,rect,green,green,2&quot;);</span>
  <span class="keywordflow">if</span> (color == BLUE)
    dispStr.setTagArg(<span class="stringliteral">&quot;b&quot;</span>, 3, <span class="stringliteral">&quot;blue&quot;</span>);
        <span class="comment">//dispStr.parse(&quot;b=40,40,rect,blue,blue,2&quot;);</span>
  <span class="keywordflow">if</span> (color == RED)
    dispStr.setTagArg(<span class="stringliteral">&quot;b&quot;</span>, 3, <span class="stringliteral">&quot;red&quot;</span>);
        <span class="comment">//dispStr.parse(&quot;b=40,40,rect,red,red,2&quot;);</span>
  <span class="keywordflow">if</span> (color == BLACK)
    dispStr.setTagArg(<span class="stringliteral">&quot;b&quot;</span>, 3, <span class="stringliteral">&quot;black&quot;</span>);
        <span class="comment">//dispStr.parse(&quot;b=40,40,rect,black,black,2&quot;);</span>
  <span class="keywordflow">if</span> (color == YELLOW)
    dispStr.setTagArg(<span class="stringliteral">&quot;b&quot;</span>, 3, <span class="stringliteral">&quot;yellow&quot;</span>);
        <span class="comment">//dispStr.parse(&quot;b=40,40,rect,yellow,yellow,2&quot;);</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6b362134693ef8ab49abdea9a7d6dda1"></a><!-- doxytag: member="BMacLayer::handleLowerControl" ref="a6b362134693ef8ab49abdea9a7d6dda1" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BMacLayer::handleLowerControl </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle control messages from lower layer. </p>
<p>Handle transmission over messages: either send another preambles or the data packet itself. </p>

<p>Reimplemented from <a class="el" href="a00026.html#a796d456d593dfab3188b37e506dd76a8">BaseMacLayer</a>.</p>

<p>References <a class="el" href="a00134.html#a00dd43576b4da205117d53bd3baadc71">MacToPhyInterface::getRadioState()</a>, <a class="el" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411">macState</a>, <a class="el" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea">BaseMacLayer::phy</a>, <a class="el" href="a00134.html#a36bc50a86bf1cc0f9efd374613d61a52a876c7366bd2bcb675b41e60007831d06">MacToPhyInterface::RADIO_SWITCHING_OVER</a>, <a class="el" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a4f6c3dfae0f5fccb76b1d42f6ccc785d">MiximRadio::TX</a>, and <a class="el" href="a00026.html#a49e0e548a6c20d002bd67afa7b76c483a5e5e0e55f7cc75b0d8bad06a212371f1">BaseMacLayer::TX_OVER</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Transmission of one packet is over</span>
    <span class="keywordflow">if</span>(msg-&gt;getKind() == <a class="code" href="a00026.html#a49e0e548a6c20d002bd67afa7b76c483a5e5e0e55f7cc75b0d8bad06a212371f1">MacToPhyInterface::TX_OVER</a>) {
      <span class="keywordflow">if</span> (<a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> == WAIT_TX_DATA_OVER)
      {
        scheduleAt(simTime(), data_tx_over);
      }
      <span class="keywordflow">if</span> (<a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> == WAIT_ACK_TX)
      {
        scheduleAt(simTime(), ack_tx_over);
      }
    }
    <span class="comment">// Radio switching (to RX or TX) ir over, ignore switching to SLEEP.</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(msg-&gt;getKind() == <a class="code" href="a00134.html#a36bc50a86bf1cc0f9efd374613d61a52a876c7366bd2bcb675b41e60007831d06" title="Indicates the end of a radio switch.">MacToPhyInterface::RADIO_SWITCHING_OVER</a>) {
      <span class="comment">// we just switched to TX after CCA, so simply send the first</span>
      <span class="comment">// sendPremable self message</span>
      <span class="keywordflow">if</span> ((<a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> == SEND_PREAMBLE) &amp;&amp; (<a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#a00dd43576b4da205117d53bd3baadc71" title="Returns the current state the radio is in. See RadioState for possible values.">getRadioState</a>() == <a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a4f6c3dfae0f5fccb76b1d42f6ccc785d" title="transmitting state">MiximRadio::TX</a>))
      {
        scheduleAt(simTime(), send_preamble);
      }
      <span class="keywordflow">if</span> ((<a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> == SEND_ACK) &amp;&amp; (<a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#a00dd43576b4da205117d53bd3baadc71" title="Returns the current state the radio is in. See RadioState for possible values.">getRadioState</a>() == <a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a4f6c3dfae0f5fccb76b1d42f6ccc785d" title="transmitting state">MiximRadio::TX</a>))
      {
        scheduleAt(simTime(), send_ack);
      }
      <span class="comment">// we were waiting for acks, but none came. we switched to TX and now</span>
      <span class="comment">// need to resend data</span>
      <span class="keywordflow">if</span> ((<a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> == SEND_DATA) &amp;&amp; (<a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#a00dd43576b4da205117d53bd3baadc71" title="Returns the current state the radio is in. See RadioState for possible values.">getRadioState</a>() == <a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a4f6c3dfae0f5fccb76b1d42f6ccc785d" title="transmitting state">MiximRadio::TX</a>))
      {
        scheduleAt(simTime(), resend_data);
      }

    }
    <span class="keywordflow">else</span> {
        debugEV &lt;&lt; <span class="stringliteral">&quot;control message with wrong kind -- deleting\n&quot;</span>;
    }
    <span class="keyword">delete</span> msg;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac16d3f8eda5c8d43c4a33a581aa4fbfb"></a><!-- doxytag: member="BMacLayer::handleLowerMsg" ref="ac16d3f8eda5c8d43c4a33a581aa4fbfb" args="(cMessage *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BMacLayer::handleLowerMsg </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle messages from lower layer. </p>
<p>Handle BMAC preambles and received data packets. </p>

<p>Reimplemented from <a class="el" href="a00026.html#a413375cec02b990a521b62086a02264c">BaseMacLayer</a>.</p>

<p>References <a class="el" href="a00035.html#a0d6b089a3e75932385bf38815b44b8bc">handleSelfMsg()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// simply pass the massage as self message, to be processed by the FSM.</span>
  <a class="code" href="a00035.html#a0d6b089a3e75932385bf38815b44b8bc" title="Handle self messages such as timers.">handleSelfMsg</a>(msg);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0d6b089a3e75932385bf38815b44b8bc"></a><!-- doxytag: member="BMacLayer::handleSelfMsg" ref="a0d6b089a3e75932385bf38815b44b8bc" args="(cMessage *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BMacLayer::handleSelfMsg </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle self messages such as timers. </p>
<p>Handle own messages: BMAC_WAKEUP: wake up the node, check the channel for some time. BMAC_CHECK_CHANNEL: if the channel is free, check whether there is something in the queue and switch the radio to TX. When switched to TX, the node will start sending preambles for a full slot duration. If the channel is busy, stay awake to receive message. Schedule a timeout to handle false alarms. BMAC_SEND_PREAMBLES: sending of preambles over. Next time the data packet will be send out (single one). BMAC_TIMEOUT_DATA: timeout the node after a false busy channel alarm. Go back to sleep. </p>

<p>Reimplemented from <a class="el" href="a00026.html#add5277c1a60dab10db40c8d9641e48c4">BaseMacLayer</a>.</p>

<p>References <a class="el" href="a00035.html#a727a243ed5bfe43d34452f310860fd74">changeDisplayColor()</a>, <a class="el" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7">checkInterval</a>, <a class="el" href="a00026.html#a998b4c4c56074a354b50f8c4fc5d6d4c">BaseMacLayer::decapsMsg()</a>, <a class="el" href="a00134.html#a00dd43576b4da205117d53bd3baadc71">MacToPhyInterface::getRadioState()</a>, <a class="el" href="a00117.html#a3890f1c7314c5695e32252468e6bd5a5">LAddress::isL2Broadcast()</a>, <a class="el" href="a00117.html#a9f975ad0433f1fb8a01164f266a41f62">LAddress::L2BROADCAST</a>, <a class="el" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e">macQueue</a>, <a class="el" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411">macState</a>, <a class="el" href="a00035.html#ac89bcf80f1642195df80253067ba92e5">maxTxAttempts</a>, <a class="el" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2">BaseMacLayer::myMacAddr</a>, <a class="el" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea">BaseMacLayer::phy</a>, <a class="el" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a2c1aea88fe8363141c138da817461953">MiximRadio::RX</a>, <a class="el" href="a00035.html#a2f19dac6f5e7041c9b65a1e547763ffa">sendDataPacket()</a>, <a class="el" href="a00035.html#af2a4df90f60f2c5b93813b5424f7ee0f">sendMacAck()</a>, <a class="el" href="a00035.html#afeb78e201913f491b8abb8416dd6eefc">sendPreamble()</a>, <a class="el" href="a00025.html#adbf061566606041db811b519f0400ed5">BaseLayer::sendUp()</a>, <a class="el" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f">MacToPhyInterface::setRadioState()</a>, <a class="el" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42">MiximRadio::SLEEP</a>, <a class="el" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea">slotDuration</a>, <a class="el" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a4f6c3dfae0f5fccb76b1d42f6ccc785d">MiximRadio::TX</a>, and <a class="el" href="a00035.html#ac44f7816182a2431558f281628808dbd">useMacAcks</a>.</p>

<p>Referenced by <a class="el" href="a00035.html#ac16d3f8eda5c8d43c4a33a581aa4fbfb">handleLowerMsg()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">switch</span> (<a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a>)
  {
  <span class="keywordflow">case</span> INIT:
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_START_BMAC)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State INIT, message BMAC_START, new state SLEEP&quot;</span> &lt;&lt; endl;
      <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(BLACK);
      <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42" title="sleeping">MiximRadio::SLEEP</a>);
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SLEEP;
      scheduleAt(simTime()+dblrand()*<a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, wakeup);
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;
  <span class="keywordflow">case</span> SLEEP:
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_WAKE_UP)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State SLEEP, message BMAC_WAKEUP, new state CCA&quot;</span> &lt;&lt; endl;
      scheduleAt(simTime() + <a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, cca_timeout);
      <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a2c1aea88fe8363141c138da817461953" title="receiving state">MiximRadio::RX</a>);
      <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(GREEN);
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = CCA;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;
  <span class="keywordflow">case</span> CCA:
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_CCA_TIMEOUT)
    {
      <span class="comment">// channel is clear</span>
      <span class="comment">// something waiting in eth queue?</span>
      <span class="keywordflow">if</span> (<a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &gt; 0)
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;State CCA, message CCA_TIMEOUT, new state&quot;</span>
              <span class="stringliteral">&quot; SEND_PREAMBLE&quot;</span> &lt;&lt; endl;
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a4f6c3dfae0f5fccb76b1d42f6ccc785d" title="transmitting state">MiximRadio::TX</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(YELLOW);
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SEND_PREAMBLE;
        scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, stop_preambles);
        <span class="keywordflow">return</span>;
      }
      <span class="comment">// if not, go back to sleep and wake up after a full period</span>
      <span class="keywordflow">else</span>
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;State CCA, message CCA_TIMEOUT, new state SLEEP&quot;</span>
             &lt;&lt; endl;
        scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, wakeup);
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SLEEP;
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42" title="sleeping">MiximRadio::SLEEP</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(BLACK);
        <span class="keywordflow">return</span>;
      }
    }
    <span class="comment">// during CCA, we received a preamble. Go to state WAIT_DATA and</span>
    <span class="comment">// schedule the timeout.</span>
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_PREAMBLE)
    {
      nbRxPreambles++;
      debugEV &lt;&lt; <span class="stringliteral">&quot;State CCA, message BMAC_PREAMBLE received, new state&quot;</span>
            <span class="stringliteral">&quot; WAIT_DATA&quot;</span> &lt;&lt; endl;
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = WAIT_DATA;
      cancelEvent(cca_timeout);
      scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a> + <a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, data_timeout);
      <span class="keyword">delete</span> msg;
      <span class="keywordflow">return</span>;
    }
    <span class="comment">// this case is very, very, very improbable, but let&#39;s do it.</span>
    <span class="comment">// if in CCA and the node receives directly the data packet, switch to</span>
    <span class="comment">// state WAIT_DATA and re-send the message</span>
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_DATA)
    {
      nbRxDataPackets++;
      debugEV &lt;&lt; <span class="stringliteral">&quot;State CCA, message BMAC_DATA, new state WAIT_DATA&quot;</span>
           &lt;&lt; endl;
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = WAIT_DATA;
      cancelEvent(cca_timeout);
      scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a> + <a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, data_timeout);
      scheduleAt(simTime(), msg);
      <span class="keywordflow">return</span>;
    }
    <span class="comment">//in case we get an ACK, we simply dicard it, because it means the end</span>
    <span class="comment">//of another communication</span>
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_ACK)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State CCA, message BMAC_ACK, new state CCA&quot;</span> &lt;&lt; endl;
      <span class="keyword">delete</span> msg;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> SEND_PREAMBLE:
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_SEND_PREAMBLE)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State SEND_PREAMBLE, message BMAC_SEND_PREAMBLE, new&quot;</span>
            <span class="stringliteral">&quot; state SEND_PREAMBLE&quot;</span> &lt;&lt; endl;
      <a class="code" href="a00035.html#afeb78e201913f491b8abb8416dd6eefc" title="Internal function to send one preamble.">sendPreamble</a>();
      scheduleAt(simTime() + 0.5f*<a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, send_preamble);
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SEND_PREAMBLE;
      <span class="keywordflow">return</span>;
    }
    <span class="comment">// simply change the state to SEND_DATA</span>
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_STOP_PREAMBLES)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State SEND_PREAMBLE, message BMAC_STOP_PREAMBLES, new&quot;</span>
            <span class="stringliteral">&quot; state SEND_DATA&quot;</span> &lt;&lt; endl;
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SEND_DATA;
      txAttempts = 1;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> SEND_DATA:
    <span class="keywordflow">if</span> ((msg-&gt;getKind() == BMAC_SEND_PREAMBLE)
      || (msg-&gt;getKind() == BMAC_RESEND_DATA))
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State SEND_DATA, message BMAC_SEND_PREAMBLE or&quot;</span>
            <span class="stringliteral">&quot; BMAC_RESEND_DATA, new state WAIT_TX_DATA_OVER&quot;</span> &lt;&lt; endl;
      <span class="comment">// send the data packet</span>
      <a class="code" href="a00035.html#a2f19dac6f5e7041c9b65a1e547763ffa" title="Internal function to send the first packet in the queue.">sendDataPacket</a>();
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = WAIT_TX_DATA_OVER;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> WAIT_TX_DATA_OVER:
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_DATA_TX_OVER)
    {
      <span class="keywordflow">if</span> ((<a class="code" href="a00035.html#ac44f7816182a2431558f281628808dbd" title="Use MAC level acks or not.">useMacAcks</a>) &amp;&amp; !<a class="code" href="a00117.html#a3890f1c7314c5695e32252468e6bd5a5" title="Test if a L2 address (pSrcAddr) is a broadcast address.">LAddress::isL2Broadcast</a>( lastDataPktDestAddr ))
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_TX_DATA_OVER, message BMAC_DATA_TX_OVER,&quot;</span>
              <span class="stringliteral">&quot; new state WAIT_ACK&quot;</span> &lt;&lt; endl;
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = WAIT_ACK;
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a2c1aea88fe8363141c138da817461953" title="receiving state">MiximRadio::RX</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(GREEN);
        scheduleAt(simTime()+<a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, ack_timeout);
      }
      <span class="keywordflow">else</span>
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_TX_DATA_OVER, message BMAC_DATA_TX_OVER,&quot;</span>
              <span class="stringliteral">&quot; new state  SLEEP&quot;</span> &lt;&lt; endl;
        <span class="keyword">delete</span> <a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.front();
        <a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.pop_front();
        <span class="comment">// if something in the queue, wakeup soon.</span>
        <span class="keywordflow">if</span> (<a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &gt; 0)
          scheduleAt(simTime() + dblrand()*<a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, wakeup);
        <span class="keywordflow">else</span>
          scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, wakeup);
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SLEEP;
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42" title="sleeping">MiximRadio::SLEEP</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(BLACK);
      }
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;
  <span class="keywordflow">case</span> WAIT_ACK:
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_ACK_TIMEOUT)
    {
      <span class="comment">// No ACK received. try again or drop.</span>
      <span class="keywordflow">if</span> (txAttempts &lt; <a class="code" href="a00035.html#ac89bcf80f1642195df80253067ba92e5" title="Maximum transmission attempts per data packet, when ACKs are used.">maxTxAttempts</a>)
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_ACK, message BMAC_ACK_TIMEOUT, new state&quot;</span>
              <span class="stringliteral">&quot; SEND_DATA&quot;</span> &lt;&lt; endl;
        txAttempts++;
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SEND_PREAMBLE;
        scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, stop_preambles);
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a4f6c3dfae0f5fccb76b1d42f6ccc785d" title="transmitting state">MiximRadio::TX</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(YELLOW);
      }
      <span class="keywordflow">else</span>
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_ACK, message BMAC_ACK_TIMEOUT, new state&quot;</span>
              <span class="stringliteral">&quot; SLEEP&quot;</span> &lt;&lt; endl;
        <span class="comment">//drop the packet</span>
        <span class="keyword">delete</span> <a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.front();
        <a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.pop_front();
        <span class="comment">// if something in the queue, wakeup soon.</span>
        <span class="keywordflow">if</span> (<a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &gt; 0)
          scheduleAt(simTime() + dblrand()*<a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, wakeup);
        <span class="keywordflow">else</span>
          scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, wakeup);
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SLEEP;
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42" title="sleeping">MiximRadio::SLEEP</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(BLACK);
        nbMissedAcks++;
      }
      <span class="keywordflow">return</span>;
    }
    <span class="comment">//ignore and other packets</span>
    <span class="keywordflow">if</span> ((msg-&gt;getKind() == BMAC_DATA) || (msg-&gt;getKind() == BMAC_PREAMBLE))
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_ACK, message BMAC_DATA or BMAC_PREMABLE, new&quot;</span>
            <span class="stringliteral">&quot; state WAIT_ACK&quot;</span> &lt;&lt; endl;
      <span class="keyword">delete</span> msg;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_ACK)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_ACK, message BMAC_ACK&quot;</span> &lt;&lt; endl;
      macpkt_ptr_t            mac = <span class="keyword">static_cast&lt;</span>macpkt_ptr_t<span class="keyword">&gt;</span>(msg);
      <span class="keyword">const</span> <a class="code" href="a00117.html#aea56b60dcb5ae8c2bde465271daf7210" title="Type definition for a L2 (MAC) address.">LAddress::L2Type</a>&amp; src = mac-&gt;getSrcAddr();
      <span class="comment">// the right ACK is received..</span>
      debugEV &lt;&lt; <span class="stringliteral">&quot;We are waiting for ACK from : &quot;</span> &lt;&lt; lastDataPktDestAddr
           &lt;&lt; <span class="stringliteral">&quot;, and ACK came from : &quot;</span> &lt;&lt; src &lt;&lt; endl;
      <span class="keywordflow">if</span> (src == lastDataPktDestAddr)
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;New state SLEEP&quot;</span> &lt;&lt; endl;
        nbRecvdAcks++;
        lastDataPktDestAddr = <a class="code" href="a00117.html#a9f975ad0433f1fb8a01164f266a41f62" title="Broadcast address for L2 addresses.">LAddress::L2BROADCAST</a>;
        cancelEvent(ack_timeout);
        <span class="keyword">delete</span> <a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.front();
        <a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.pop_front();
        <span class="comment">// if something in the queue, wakeup soon.</span>
        <span class="keywordflow">if</span> (<a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &gt; 0)
          scheduleAt(simTime() + dblrand()*<a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, wakeup);
        <span class="keywordflow">else</span>
          scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, wakeup);
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SLEEP;
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42" title="sleeping">MiximRadio::SLEEP</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(BLACK);
        lastDataPktDestAddr = <a class="code" href="a00117.html#a9f975ad0433f1fb8a01164f266a41f62" title="Broadcast address for L2 addresses.">LAddress::L2BROADCAST</a>;
      }
      <span class="keyword">delete</span> msg;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;
  <span class="keywordflow">case</span> WAIT_DATA:
    <span class="keywordflow">if</span>(msg-&gt;getKind() == BMAC_PREAMBLE)
    {
      <span class="comment">//nothing happens</span>
      debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_DATA, message BMAC_PREAMBLE, new state&quot;</span>
            <span class="stringliteral">&quot; WAIT_DATA&quot;</span> &lt;&lt; endl;
      nbRxPreambles++;
      <span class="keyword">delete</span> msg;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">if</span>(msg-&gt;getKind() == BMAC_ACK)
    {
      <span class="comment">//nothing happens</span>
      debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_DATA, message BMAC_ACK, new state WAIT_DATA&quot;</span>
           &lt;&lt; endl;
      <span class="keyword">delete</span> msg;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_DATA)
    {
      nbRxDataPackets++;
      macpkt_ptr_t            mac  = <span class="keyword">static_cast&lt;</span>macpkt_ptr_t<span class="keyword">&gt;</span>(msg);
      <span class="keyword">const</span> <a class="code" href="a00117.html#aea56b60dcb5ae8c2bde465271daf7210" title="Type definition for a L2 (MAC) address.">LAddress::L2Type</a>&amp; dest = mac-&gt;getDestAddr();
      <span class="keyword">const</span> <a class="code" href="a00117.html#aea56b60dcb5ae8c2bde465271daf7210" title="Type definition for a L2 (MAC) address.">LAddress::L2Type</a>&amp; src  = mac-&gt;getSrcAddr();
      <span class="keywordflow">if</span> ((dest == <a class="code" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2" title="MAC address.">myMacAddr</a>) || <a class="code" href="a00117.html#a3890f1c7314c5695e32252468e6bd5a5" title="Test if a L2 address (pSrcAddr) is a broadcast address.">LAddress::isL2Broadcast</a>(dest)) {
        <a class="code" href="a00025.html#adbf061566606041db811b519f0400ed5" title="Sends a message to the upper layer.">sendUp</a>(<a class="code" href="a00026.html#a998b4c4c56074a354b50f8c4fc5d6d4c" title="decapsulate the network message from the MacPkt">decapsMsg</a>(mac));
      } <span class="keywordflow">else</span> {
        <span class="keyword">delete</span> msg;
        msg = NULL;
        mac = NULL;
      }

      cancelEvent(data_timeout);
      <span class="keywordflow">if</span> ((<a class="code" href="a00035.html#ac44f7816182a2431558f281628808dbd" title="Use MAC level acks or not.">useMacAcks</a>) &amp;&amp; (dest == <a class="code" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2" title="MAC address.">myMacAddr</a>))
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_DATA, message BMAC_DATA, new state&quot;</span>
              <span class="stringliteral">&quot; SEND_ACK&quot;</span> &lt;&lt; endl;
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SEND_ACK;
        lastDataPktSrcAddr = src;
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7a4f6c3dfae0f5fccb76b1d42f6ccc785d" title="transmitting state">MiximRadio::TX</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(YELLOW);
      }
      <span class="keywordflow">else</span>
      {
        debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_DATA, message BMAC_DATA, new state SLEEP&quot;</span>
             &lt;&lt; endl;
        <span class="comment">// if something in the queue, wakeup soon.</span>
        <span class="keywordflow">if</span> (<a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &gt; 0)
          scheduleAt(simTime() + dblrand()*<a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, wakeup);
        <span class="keywordflow">else</span>
          scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, wakeup);
        <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SLEEP;
        <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42" title="sleeping">MiximRadio::SLEEP</a>);
        <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(BLACK);
      }
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_DATA_TIMEOUT)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_DATA, message BMAC_DATA_TIMEOUT, new state&quot;</span>
            <span class="stringliteral">&quot; SLEEP&quot;</span> &lt;&lt; endl;
      <span class="comment">// if something in the queue, wakeup soon.</span>
      <span class="keywordflow">if</span> (<a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &gt; 0)
        scheduleAt(simTime() + dblrand()*<a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, wakeup);
      <span class="keywordflow">else</span>
        scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, wakeup);
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SLEEP;
      <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42" title="sleeping">MiximRadio::SLEEP</a>);
      <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(BLACK);
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;
  <span class="keywordflow">case</span> SEND_ACK:
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_SEND_ACK)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State SEND_ACK, message BMAC_SEND_ACK, new state&quot;</span>
            <span class="stringliteral">&quot; WAIT_ACK_TX&quot;</span> &lt;&lt; endl;
      <span class="comment">// send now the ack packet</span>
      <a class="code" href="a00035.html#af2a4df90f60f2c5b93813b5424f7ee0f" title="Internal function to send an ACK.">sendMacAck</a>();
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = WAIT_ACK_TX;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;
  <span class="keywordflow">case</span> WAIT_ACK_TX:
    <span class="keywordflow">if</span> (msg-&gt;getKind() == BMAC_ACK_TX_OVER)
    {
      debugEV &lt;&lt; <span class="stringliteral">&quot;State WAIT_ACK_TX, message BMAC_ACK_TX_OVER, new state&quot;</span>
            <span class="stringliteral">&quot; SLEEP&quot;</span> &lt;&lt; endl;
      <span class="comment">// ack sent, go to sleep now.</span>
      <span class="comment">// if something in the queue, wakeup soon.</span>
      <span class="keywordflow">if</span> (<a class="code" href="a00035.html#ae34984aa9d79ca356e9d310cf7fe431e" title="A queue to store packets from upper layer in case another packet is still waiting for transmission...">macQueue</a>.size() &gt; 0)
        scheduleAt(simTime() + dblrand()*<a class="code" href="a00035.html#a6672d3d6469bf079cea9e9fc0430cfd7" title="The duration of CCA.">checkInterval</a>, wakeup);
      <span class="keywordflow">else</span>
        scheduleAt(simTime() + <a class="code" href="a00035.html#ad52c754e33e66f1811d4d0a52f748aea" title="The duration of the slot in secs.">slotDuration</a>, wakeup);
      <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> = SLEEP;
      <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#ad25abbad9aa16bdbf24bf1dd582b1c6f" title="Tells the BasePhyLayer to switch to the specified radio state.">setRadioState</a>(<a class="code" href="a00141.html#a5d69aacb1cf6a57827f07224219fccb7afd684ca0a1c84f153dec831272ccde42" title="sleeping">MiximRadio::SLEEP</a>);
      <a class="code" href="a00035.html#a727a243ed5bfe43d34452f310860fd74" title="Internal function to change the color of the node.">changeDisplayColor</a>(BLACK);
      lastDataPktSrcAddr = <a class="code" href="a00117.html#a9f975ad0433f1fb8a01164f266a41f62" title="Broadcast address for L2 addresses.">LAddress::L2BROADCAST</a>;
      <span class="keywordflow">return</span>;
    }
    <span class="keywordflow">break</span>;
  }
  opp_error(<span class="stringliteral">&quot;Undefined event of type %d in state %d (Radio state %d)!&quot;</span>,
        msg-&gt;getKind(), <a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a>, <a class="code" href="a00026.html#aa7b1e6bdb734765a9f4eff7d486dfbea" title="Handler to the physical layer.">phy</a>-&gt;<a class="code" href="a00134.html#a00dd43576b4da205117d53bd3baadc71" title="Returns the current state the radio is in. See RadioState for possible values.">getRadioState</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a43c9f5377b89dd4cd4e4e48fb3e96107"></a><!-- doxytag: member="BMacLayer::handleUpperMsg" ref="a43c9f5377b89dd4cd4e4e48fb3e96107" args="(cMessage *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BMacLayer::handleUpperMsg </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle messages from upper layer. </p>
<p>Check whether the queue is not full: if yes, print a warning and drop the packet. Then initiate sending of the packet, if the node is sleeping. Do nothing, if node is working. </p>

<p>Reimplemented from <a class="el" href="a00026.html#a6de2ca07018de313a7147a03e6d77bff">BaseMacLayer</a>.</p>

<p>References <a class="el" href="a00035.html#acff92f0d4ba44ee5035c0d3729729257">addToQueue()</a>, and <a class="el" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411">macState</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> pktAdded = <a class="code" href="a00035.html#acff92f0d4ba44ee5035c0d3729729257" title="Internal function to add a new packet from upper to the queue.">addToQueue</a>(msg);
  <span class="keywordflow">if</span> (!pktAdded)
    <span class="keywordflow">return</span>;
  <span class="comment">// force wakeup now</span>
  <span class="keywordflow">if</span> (wakeup-&gt;isScheduled() &amp;&amp; (<a class="code" href="a00035.html#a3f547e9f97f0c07b692c32c4183c5411" title="The current state of the protocol.">macState</a> == SLEEP))
  {
    cancelEvent(wakeup);
    scheduleAt(simTime() + dblrand()*0.1f, wakeup);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af2a4df90f60f2c5b93813b5424f7ee0f"></a><!-- doxytag: member="BMacLayer::sendMacAck" ref="af2a4df90f60f2c5b93813b5424f7ee0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BMacLayer::sendMacAck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to send an ACK. </p>
<p>Send one short preamble packet immediately. </p>

<p>References <a class="el" href="a00035.html#a5f0384e6e1a28a7d303ec5d6d2cc9dd4">attachSignal()</a>, <a class="el" href="a00026.html#a26ddb186455b73c8dc8b5698296804d2">BaseMacLayer::headerLength</a>, <a class="el" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2">BaseMacLayer::myMacAddr</a>, and <a class="el" href="a00025.html#a1873d6e3fc6d92cf8482b39f1c5ac6c8">BaseLayer::sendDown()</a>.</p>

<p>Referenced by <a class="el" href="a00035.html#a0d6b089a3e75932385bf38815b44b8bc">handleSelfMsg()</a>.</p>
<div class="fragment"><pre class="fragment">{
  macpkt_ptr_t ack = <span class="keyword">new</span> MacPkt();
  ack-&gt;setSrcAddr(<a class="code" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2" title="MAC address.">myMacAddr</a>);
  ack-&gt;setDestAddr(lastDataPktSrcAddr);
  ack-&gt;setKind(BMAC_ACK);
  ack-&gt;setBitLength(<a class="code" href="a00026.html#a26ddb186455b73c8dc8b5698296804d2" title="Pointer to the arp module.">headerLength</a>);

  <span class="comment">//attach signal and send down</span>
  <a class="code" href="a00035.html#a5f0384e6e1a28a7d303ec5d6d2cc9dd4" title="Internal function to attach a signal to the packet.">attachSignal</a>(ack);
  <a class="code" href="a00025.html#a1873d6e3fc6d92cf8482b39f1c5ac6c8" title="Sends a message to the lower layer.">sendDown</a>(ack);
  nbTxAcks++;
  <span class="comment">//endSimulation();</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="afeb78e201913f491b8abb8416dd6eefc"></a><!-- doxytag: member="BMacLayer::sendPreamble" ref="afeb78e201913f491b8abb8416dd6eefc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BMacLayer::sendPreamble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to send one preamble. </p>
<p>Send one short preamble packet immediately. </p>

<p>References <a class="el" href="a00035.html#a5f0384e6e1a28a7d303ec5d6d2cc9dd4">attachSignal()</a>, <a class="el" href="a00026.html#a26ddb186455b73c8dc8b5698296804d2">BaseMacLayer::headerLength</a>, <a class="el" href="a00117.html#a9f975ad0433f1fb8a01164f266a41f62">LAddress::L2BROADCAST</a>, <a class="el" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2">BaseMacLayer::myMacAddr</a>, and <a class="el" href="a00025.html#a1873d6e3fc6d92cf8482b39f1c5ac6c8">BaseLayer::sendDown()</a>.</p>

<p>Referenced by <a class="el" href="a00035.html#a0d6b089a3e75932385bf38815b44b8bc">handleSelfMsg()</a>.</p>
<div class="fragment"><pre class="fragment">{
  macpkt_ptr_t preamble = <span class="keyword">new</span> MacPkt();
  preamble-&gt;setSrcAddr(<a class="code" href="a00026.html#a8a26df9da07801d8ccb530530ef57ee2" title="MAC address.">myMacAddr</a>);
  preamble-&gt;setDestAddr(<a class="code" href="a00117.html#a9f975ad0433f1fb8a01164f266a41f62" title="Broadcast address for L2 addresses.">LAddress::L2BROADCAST</a>);
  preamble-&gt;setKind(BMAC_PREAMBLE);
  preamble-&gt;setBitLength(<a class="code" href="a00026.html#a26ddb186455b73c8dc8b5698296804d2" title="Pointer to the arp module.">headerLength</a>);

  <span class="comment">//attach signal and send down</span>
  <a class="code" href="a00035.html#a5f0384e6e1a28a7d303ec5d6d2cc9dd4" title="Internal function to attach a signal to the packet.">attachSignal</a>(preamble);
  <a class="code" href="a00025.html#a1873d6e3fc6d92cf8482b39f1c5ac6c8" title="Sends a message to the lower layer.">sendDown</a>(preamble);
  nbTxPreambles++;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a344d41bb6a3dd348f0b193a253a44e63"></a><!-- doxytag: member="BMacLayer::animation" ref="a344d41bb6a3dd348f0b193a253a44e63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00035.html#a344d41bb6a3dd348f0b193a253a44e63">BMacLayer::animation</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Animate (colorize) the nodes. </p>
<p>The color of the node reflects its basic status (not the exact state!) BLACK - node is sleeping GREEN - node is receiving YELLOW - node is sending </p>

<p>Referenced by <a class="el" href="a00035.html#a727a243ed5bfe43d34452f310860fd74">changeDisplayColor()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Projects/MiXiM/extsrc/mixim/src/modules/mac/<a class="el" href="a00424_source.html">BMacLayer.h</a></li>
<li>D:/Projects/MiXiM/extsrc/mixim/src/modules/mac/BMacLayer.cc</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00035.html">BMacLayer</a>      </li>

    <li class="footer">Generated on Tue Mar 5 2013 21:26:31 for MiXiM by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
