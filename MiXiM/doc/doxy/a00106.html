<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: InterfaceTable Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MiXiM
   &#160;<span id="projectnumber">2.3</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00106.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">InterfaceTable Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="InterfaceTable" --><!-- doxytag: inherits="IInterfaceTable,INotifiable" -->
<p><code>#include &lt;<a class="el" href="a00390_source.html">InterfaceTable.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for InterfaceTable:</div>
<div class="dyncontent">
<div class="center"><img src="a00777.png" border="0" usemap="#InterfaceTable_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for InterfaceTable:</div>
<div class="dyncontent">
<div class="center"><img src="a00778.png" border="0" usemap="#InterfaceTable_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00779.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#abde330e4adcc5a7495f89b8cd6154275">getFullPath</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a70303b94020a300c74222695a2cfa261">receiveChangeNotification</a> (int category, const cObject *details)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cModule *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a999f85862dc558747ce9d8e2393188bb">getHostModule</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#af43ca2b4f54392ce974effc35dcf72d1">addInterface</a> (<a class="el" href="a00104.html">InterfaceEntry</a> *entry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a59bf4ac426a9fd86c5ce4cb2c9fcc16e">deleteInterface</a> (<a class="el" href="a00104.html">InterfaceEntry</a> *entry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#aa7bbc08564b199d7820f9fb5dafedead">getNumInterfaces</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a20068628e72377ed78735e6b008a0a9f">getInterface</a> (int pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a3acb58a75de2e7d443c6abd0e7bd2548">getInterfaceById</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a281b09bc65fc43109563bff6d9e55995">getInterfaceByNodeOutputGateId</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#ad6eb1529b3d8ed007feea079e1f5d9cd">getInterfaceByNodeInputGateId</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#abc0aa1cd6740d6808c09c3969969bd6f">getInterfaceByNetworkLayerGateIndex</a> (int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a109c3bcfee676b91628bef4582839f50">getInterfaceByInterfaceModule</a> (cModule *ifmod)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a3f953c2e608d84f14cfcaaf32ff6cbe1">getInterfaceByName</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a60849d96d27149120445ee5429462d91">getFirstLoopbackInterface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a14c696f299054ee4617612e3c7e721b9">getFirstMulticastInterface</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ffd914a1c868644a125750bf7bea75c"></a><!-- doxytag: member="InterfaceTable::InterfaceVector" ref="a3ffd914a1c868644a125750bf7bea75c" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00104.html">InterfaceEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InterfaceVector</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84ad7ffc48e1d42ca93284fe033823b0"></a><!-- doxytag: member="InterfaceTable::updateDisplayString" ref="a84ad7ffc48e1d42ca93284fe033823b0" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateDisplayString</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a541865f79aa57c4214cf1e1bd98b54bf"></a><!-- doxytag: member="InterfaceTable::updateLinkDisplayString" ref="a541865f79aa57c4214cf1e1bd98b54bf" args="(InterfaceEntry *entry)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateLinkDisplayString</b> (<a class="el" href="a00104.html">InterfaceEntry</a> *entry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86d43c8e68646df65f9a53478139bd3d"></a><!-- doxytag: member="InterfaceTable::discoverConnectingGates" ref="a86d43c8e68646df65f9a53478139bd3d" args="(InterfaceEntry *entry)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>discoverConnectingGates</b> (<a class="el" href="a00104.html">InterfaceEntry</a> *entry)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56f4588cd3260e1ba58b9af6b812d6ae"></a><!-- doxytag: member="InterfaceTable::interfaceChanged" ref="a56f4588cd3260e1ba58b9af6b812d6ae" args="(InterfaceEntry *entry, int category)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>interfaceChanged</b> (<a class="el" href="a00104.html">InterfaceEntry</a> *entry, int category)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5da237cf1d0ab4de1ead24a6fa930f9"></a><!-- doxytag: member="InterfaceTable::invalidateTmpInterfaceList" ref="ad5da237cf1d0ab4de1ead24a6fa930f9" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>invalidateTmpInterfaceList</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f964712f929db684d0c6e5febc658f2"></a><!-- doxytag: member="InterfaceTable::numInitStages" ref="a9f964712f929db684d0c6e5febc658f2" args="() const " -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>numInitStages</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab92373cbd67155557293fbccc2ac1466"></a><!-- doxytag: member="InterfaceTable::initialize" ref="ab92373cbd67155557293fbccc2ac1466" args="(int stage)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> (int stage)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html#a101a52971a1de7df6479a3412ec5940c">handleMessage</a> (cMessage *)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a813da979ea8934dd9d1bf7f82831b0"></a><!-- doxytag: member="InterfaceTable::nb" ref="a4a813da979ea8934dd9d1bf7f82831b0" args="" -->
<a class="el" href="a00164.html">NotificationBoard</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>nb</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a770ff6852b4d38adf4796786d9d46c6a"></a><!-- doxytag: member="InterfaceTable::idToInterface" ref="a770ff6852b4d38adf4796786d9d46c6a" args="" -->
InterfaceVector&#160;</td><td class="memItemRight" valign="bottom"><b>idToInterface</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a735aed31ccdb2616a012c3a36ae812a3"></a><!-- doxytag: member="InterfaceTable::tmpNumInterfaces" ref="a735aed31ccdb2616a012c3a36ae812a3" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>tmpNumInterfaces</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a386b4b375178b5cbb5de18cdcb74042b"></a><!-- doxytag: member="InterfaceTable::tmpInterfaceList" ref="a386b4b375178b5cbb5de18cdcb74042b" args="" -->
<a class="el" href="a00104.html">InterfaceEntry</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>tmpInterfaceList</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents the interface table. This object has one instance per host or router. It has methods to manage the interface table, so one can access functionality similar to the "ifconfig" command.</p>
<p>See the NED documentation for general overview.</p>
<p>This is a simple module without gates, it requires function calls to it (message handling does nothing). Methods are provided for reading and updating the interface table.</p>
<p>Interfaces are dynamically registered: at the start of the simulation, every L2 module adds its own <a class="el" href="a00104.html">InterfaceEntry</a> to the table; after that, IPv4's IRoutingTable and IPv6's RoutingTable6 (an possibly, further L3 protocols) add protocol-specific data on each <a class="el" href="a00104.html">InterfaceEntry</a> (see IPv4InterfaceData, IPv6InterfaceData, and InterfaceEntry::setIPv4Data(), InterfaceEntry::setIPv6Data())</p>
<p>Interfaces are represented by <a class="el" href="a00104.html">InterfaceEntry</a> objects.</p>
<p>When interfaces need to be reliably and efficiently identified from other modules, interfaceIds should be used. They are better suited than pointers because when an interface gets removed (see <a class="el" href="a00106.html#a59bf4ac426a9fd86c5ce4cb2c9fcc16e">deleteInterface()</a>), it is often impossible/impractical to invalidate all pointers to it, and also because pointers are not necessarily unique (a new <a class="el" href="a00104.html">InterfaceEntry</a> may get allocated exactly at the address of a previously deleted one). Interface Ids are unique (Ids of removed interfaces are not issued again), stale Ids can be detected, and they are also invariant to insertion/deletion.</p>
<p>Clients can get notified about interface changes by subscribing to the following notifications in <a class="el" href="a00164.html">NotificationBoard</a>: NF_INTERFACE_CREATED, NF_INTERFACE_DELETED, NF_INTERFACE_STATE_CHANGED, NF_INTERFACE_CONFIG_CHANGED. State change gets fired for up/down events; all other changes fire as config change.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00104.html">InterfaceEntry</a> </dd></dl>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af43ca2b4f54392ce974effc35dcf72d1"></a><!-- doxytag: member="InterfaceTable::addInterface" ref="af43ca2b4f54392ce974effc35dcf72d1" args="(InterfaceEntry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InterfaceTable::addInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds an interface. The entry-&gt;getInterfaceModule() will be used to discover and fill in getNetworkLayerGateIndex(), getNodeOutputGateId(), and getNodeInputGateId() in <a class="el" href="a00104.html">InterfaceEntry</a>. It should be NULL if this is a virtual interface (e.g. loopback). </p>

<p>Implements <a class="el" href="a00100.html#a7b54fe5e63bb7d4c76483b7fa27e506f">IInterfaceTable</a>.</p>

<p>References <a class="el" href="a00164.html#a903a21cc32b9b3c8589765b86a767f8e">NotificationBoard::fireChangeNotification()</a>, and <a class="el" href="a00106.html#a3f953c2e608d84f14cfcaaf32ff6cbe1">getInterfaceByName()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!nb)
        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;InterfaceTable must precede all network interface modules in the node&#39;s NED definition&quot;</span>);
    <span class="comment">// check name is unique</span>
    <span class="keywordflow">if</span> (<a class="code" href="a00106.html#a3f953c2e608d84f14cfcaaf32ff6cbe1">getInterfaceByName</a>(entry-&gt;getName())!=NULL)
        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;addInterface(): interface &#39;%s&#39; already registered&quot;</span>, entry-&gt;getName());

    <span class="comment">// insert</span>
    entry-&gt;setInterfaceId(INTERFACEIDS_START + idToInterface.size());
    entry-&gt;setInterfaceTable(<span class="keyword">this</span>);
    idToInterface.push_back(entry);
    invalidateTmpInterfaceList();

    <span class="comment">// fill in networkLayerGateIndex, nodeOutputGateId, nodeInputGateId</span>
    discoverConnectingGates(entry);

    nb-&gt;<a class="code" href="a00164.html#a903a21cc32b9b3c8589765b86a767f8e">fireChangeNotification</a>(NF_INTERFACE_CREATED, entry);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a59bf4ac426a9fd86c5ce4cb2c9fcc16e"></a><!-- doxytag: member="InterfaceTable::deleteInterface" ref="a59bf4ac426a9fd86c5ce4cb2c9fcc16e" args="(InterfaceEntry *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InterfaceTable::deleteInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00104.html">InterfaceEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes the given interface from the table. Indices of existing interfaces (see <a class="el" href="a00106.html#a20068628e72377ed78735e6b008a0a9f">getInterface(int)</a>) may change. It is an error if the given interface is not in the table. </p>

<p>Implements <a class="el" href="a00100.html#a229a92e5d530127efb262e8fe7acfdf9">IInterfaceTable</a>.</p>

<p>References <a class="el" href="a00164.html#a903a21cc32b9b3c8589765b86a767f8e">NotificationBoard::fireChangeNotification()</a>, and <a class="el" href="a00106.html#a3acb58a75de2e7d443c6abd0e7bd2548">getInterfaceById()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> <span class="keywordtype">id</span> = entry-&gt;getInterfaceId();
    <span class="keywordflow">if</span> (entry != <a class="code" href="a00106.html#a3acb58a75de2e7d443c6abd0e7bd2548">getInterfaceById</a>(<span class="keywordtype">id</span>))
        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;deleteInterface(): interface &#39;%s&#39; not found in interface table&quot;</span>, entry-&gt;getName());

    nb-&gt;<a class="code" href="a00164.html#a903a21cc32b9b3c8589765b86a767f8e">fireChangeNotification</a>(NF_INTERFACE_DELETED, entry);  <span class="comment">// actually, only going to be deleted</span>

    idToInterface[<span class="keywordtype">id</span> - INTERFACEIDS_START] = NULL;
    <span class="keyword">delete</span> entry;
    invalidateTmpInterfaceList();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a60849d96d27149120445ee5429462d91"></a><!-- doxytag: member="InterfaceTable::getFirstLoopbackInterface" ref="a60849d96d27149120445ee5429462d91" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getFirstLoopbackInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the first interface with the isLoopback flag set. (If there's no loopback, it returns NULL -- but this should never happen because <a class="el" href="a00106.html">InterfaceTable</a> itself registers a loopback interface on startup.) </p>

<p>Implements <a class="el" href="a00100.html#ad9b040947200941201b8c82d35c7abee">IInterfaceTable</a>.</p>
<div class="fragment"><pre class="fragment">{
    Enter_Method_Silent();
    <span class="keywordtype">int</span> n = idToInterface.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
        <span class="keywordflow">if</span> (idToInterface[i] &amp;&amp; idToInterface[i]-&gt;isLoopback())
            <span class="keywordflow">return</span> idToInterface[i];
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a14c696f299054ee4617612e3c7e721b9"></a><!-- doxytag: member="InterfaceTable::getFirstMulticastInterface" ref="a14c696f299054ee4617612e3c7e721b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getFirstMulticastInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the first multicast capable interface. If there is no such interface, then returns NULL. </p>

<p>Implements <a class="el" href="a00100.html#a5d953f7e65da1885c6c85d0dfa890874">IInterfaceTable</a>.</p>
<div class="fragment"><pre class="fragment">{
    Enter_Method_Silent();
    <span class="keywordtype">int</span> n = idToInterface.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
        <span class="keywordflow">if</span> (idToInterface[i] &amp;&amp; idToInterface[i]-&gt;isMulticast() &amp;&amp; !idToInterface[i]-&gt;isLoopback())
            <span class="keywordflow">return</span> idToInterface[i];
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abde330e4adcc5a7495f89b8cd6154275"></a><!-- doxytag: member="InterfaceTable::getFullPath" ref="abde330e4adcc5a7495f89b8cd6154275" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string InterfaceTable::getFullPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Module path name </p>

<p>Implements <a class="el" href="a00100.html#a1047517c24c981f2069367ca576a9c81">IInterfaceTable</a>.</p>
<div class="fragment"><pre class="fragment">{<span class="keywordflow">return</span> <a class="code" href="a00106.html#abde330e4adcc5a7495f89b8cd6154275">cSimpleModule::getFullPath</a>();}
</pre></div>
</div>
</div>
<a class="anchor" id="a999f85862dc558747ce9d8e2393188bb"></a><!-- doxytag: member="InterfaceTable::getHostModule" ref="a999f85862dc558747ce9d8e2393188bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cModule * InterfaceTable::getHostModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the host or router this interface table lives in. </p>

<p>Implements <a class="el" href="a00100.html#a2f0c6da3baff7416b8914d8a393bff7f">IInterfaceTable</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> findContainingNode(<span class="keyword">this</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a20068628e72377ed78735e6b008a0a9f"></a><!-- doxytag: member="InterfaceTable::getInterface" ref="a20068628e72377ed78735e6b008a0a9f" args="(int pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getInterface </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the <a class="el" href="a00104.html">InterfaceEntry</a> specified by an index 0..numInterfaces-1. Throws an error if index is out of range.</p>
<p>Note that this index is NOT the same as interfaceId! Indices are not guaranteed to stay the same after interface addition/deletion, so cannot be used to reliably identify the interface. Use interfaceId to refer to interfaces from other modules or from messages/packets. </p>

<p>Implements <a class="el" href="a00100.html#a19ce4ca3b47b52b8e2b67c25806c4b49">IInterfaceTable</a>.</p>

<p>References <a class="el" href="a00106.html#aa7bbc08564b199d7820f9fb5dafedead">getNumInterfaces()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> n = <a class="code" href="a00106.html#aa7bbc08564b199d7820f9fb5dafedead">getNumInterfaces</a>(); <span class="comment">// also fills tmpInterfaceList</span>
    <span class="keywordflow">if</span> (pos&lt;0 || pos&gt;=n)
        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;getInterface(): interface index %d out of range 0..%d&quot;</span>, pos, n-1);

    <span class="keywordflow">if</span> (!tmpInterfaceList)
    {
        <span class="comment">// collect non-NULL elements into tmpInterfaceList[]</span>
        tmpInterfaceList = <span class="keyword">new</span> <a class="code" href="a00104.html">InterfaceEntry</a> *[n];
        <span class="keywordtype">int</span> k = 0;
        <span class="keywordtype">int</span> maxId = idToInterface.size();
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;maxId; i++)
            <span class="keywordflow">if</span> (idToInterface[i])
                tmpInterfaceList[k++] = idToInterface[i];
    }

    <span class="keywordflow">return</span> tmpInterfaceList[pos];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3acb58a75de2e7d443c6abd0e7bd2548"></a><!-- doxytag: member="InterfaceTable::getInterfaceById" ref="a3acb58a75de2e7d443c6abd0e7bd2548" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getInterfaceById </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an interface by its Id. Ids are guaranteed to be invariant to interface deletions/additions. Returns NULL if there is no such interface (This allows detecting stale IDs without raising an error.) </p>

<p>Implements <a class="el" href="a00100.html#a92764d620c345b7261de20e9ee5247d7">IInterfaceTable</a>.</p>

<p>Referenced by <a class="el" href="a00106.html#a59bf4ac426a9fd86c5ce4cb2c9fcc16e">deleteInterface()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">id</span> -= INTERFACEIDS_START;
    <span class="keywordflow">return</span> (id&lt;0 || id&gt;=(<span class="keywordtype">int</span>)idToInterface.size()) ? NULL : idToInterface[<span class="keywordtype">id</span>];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a109c3bcfee676b91628bef4582839f50"></a><!-- doxytag: member="InterfaceTable::getInterfaceByInterfaceModule" ref="a109c3bcfee676b91628bef4582839f50" args="(cModule *ifmod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getInterfaceByInterfaceModule </td>
          <td>(</td>
          <td class="paramtype">cModule *&#160;</td>
          <td class="paramname"><em>ifmod</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an interface by one of its component module (e.g. PPP). Returns NULL if not found. </p>

<p>Implements <a class="el" href="a00100.html#a54ae8859390945b1d565e6732f27f848">IInterfaceTable</a>.</p>

<p>References <a class="el" href="a00106.html#ad6eb1529b3d8ed007feea079e1f5d9cd">getInterfaceByNodeInputGateId()</a>, and <a class="el" href="a00106.html#a281b09bc65fc43109563bff6d9e55995">getInterfaceByNodeOutputGateId()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// ifmod is something like &quot;host.eth[1].mac&quot;; climb up to find &quot;host.eth[1]&quot; from it</span>
    cModule *host = getParentModule();
    <span class="keywordflow">while</span> (ifmod &amp;&amp; ifmod-&gt;getParentModule()!=host)
        ifmod = ifmod-&gt;getParentModule();
    <span class="keywordflow">if</span> (!ifmod)
        <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;addInterface(): specified module is not in this host/router&quot;</span>);

    <span class="keywordtype">int</span> nodeInputGateId = -1, nodeOutputGateId = -1;
    <span class="keywordflow">for</span> (GateIterator i(ifmod); !i.end(); i++)
    {
        cGate *g = i();
        <span class="keywordflow">if</span> (!g) <span class="keywordflow">continue</span>;

        <span class="comment">// find the host/router&#39;s gates that internally connect to this interface</span>
        <span class="keywordflow">if</span> (g-&gt;getType()==cGate::OUTPUT &amp;&amp; g-&gt;getNextGate() &amp;&amp; g-&gt;getNextGate()-&gt;getOwnerModule()==host)
            nodeOutputGateId = g-&gt;getNextGate()-&gt;getId();
        <span class="keywordflow">if</span> (g-&gt;getType()==cGate::INPUT &amp;&amp; g-&gt;getPreviousGate() &amp;&amp; g-&gt;getPreviousGate()-&gt;getOwnerModule()==host)
            nodeInputGateId = g-&gt;getPreviousGate()-&gt;getId();
    }

    <a class="code" href="a00104.html">InterfaceEntry</a> *ie = NULL;
    <span class="keywordflow">if</span> (nodeInputGateId &gt;= 0)
        ie = <a class="code" href="a00106.html#ad6eb1529b3d8ed007feea079e1f5d9cd">getInterfaceByNodeInputGateId</a>(nodeInputGateId);
    <span class="keywordflow">if</span> (!ie &amp;&amp; nodeOutputGateId &gt;= 0)
        ie = <a class="code" href="a00106.html#a281b09bc65fc43109563bff6d9e55995">getInterfaceByNodeOutputGateId</a>(nodeOutputGateId);

    ASSERT(!ie || (ie-&gt;getNodeInputGateId() == nodeInputGateId &amp;&amp; ie-&gt;getNodeOutputGateId() == nodeOutputGateId));
    <span class="keywordflow">return</span> ie;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3f953c2e608d84f14cfcaaf32ff6cbe1"></a><!-- doxytag: member="InterfaceTable::getInterfaceByName" ref="a3f953c2e608d84f14cfcaaf32ff6cbe1" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getInterfaceByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an interface given by its name. Returns NULL if not found. </p>

<p>Implements <a class="el" href="a00100.html#a8ad86ee823d6200b4f558383b39af658">IInterfaceTable</a>.</p>

<p>Referenced by <a class="el" href="a00106.html#af43ca2b4f54392ce974effc35dcf72d1">addInterface()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Enter_Method_Silent();
    <span class="keywordflow">if</span> (!name)
        <span class="keywordflow">return</span> NULL;
    <span class="keywordtype">int</span> n = idToInterface.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
        <span class="keywordflow">if</span> (idToInterface[i] &amp;&amp; !strcmp(name, idToInterface[i]-&gt;getName()))
            <span class="keywordflow">return</span> idToInterface[i];
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abc0aa1cd6740d6808c09c3969969bd6f"></a><!-- doxytag: member="InterfaceTable::getInterfaceByNetworkLayerGateIndex" ref="abc0aa1cd6740d6808c09c3969969bd6f" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getInterfaceByNetworkLayerGateIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an interface given by its getNetworkLayerGateIndex(). Returns NULL if not found. </p>

<p>Implements <a class="el" href="a00100.html#a8d10b748bc5429c706fab120c719e335">IInterfaceTable</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// linear search is OK because normally we have don&#39;t have many interfaces and this func is rarely called</span>
    Enter_Method_Silent();
    <span class="keywordtype">int</span> n = idToInterface.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
        <span class="keywordflow">if</span> (idToInterface[i] &amp;&amp; idToInterface[i]-&gt;getNetworkLayerGateIndex()==index)
            <span class="keywordflow">return</span> idToInterface[i];
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad6eb1529b3d8ed007feea079e1f5d9cd"></a><!-- doxytag: member="InterfaceTable::getInterfaceByNodeInputGateId" ref="ad6eb1529b3d8ed007feea079e1f5d9cd" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getInterfaceByNodeInputGateId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an interface given by its getNodeInputGateId(). Returns NULL if not found. </p>

<p>Implements <a class="el" href="a00100.html#a60257f3b30cedc18a80835d5be8305d9">IInterfaceTable</a>.</p>

<p>Referenced by <a class="el" href="a00106.html#a109c3bcfee676b91628bef4582839f50">getInterfaceByInterfaceModule()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// linear search is OK because normally we have don&#39;t have many interfaces and this func is rarely called</span>
    Enter_Method_Silent();
    <span class="keywordtype">int</span> n = idToInterface.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
        <span class="keywordflow">if</span> (idToInterface[i] &amp;&amp; idToInterface[i]-&gt;getNodeInputGateId()==<span class="keywordtype">id</span>)
            <span class="keywordflow">return</span> idToInterface[i];
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a281b09bc65fc43109563bff6d9e55995"></a><!-- doxytag: member="InterfaceTable::getInterfaceByNodeOutputGateId" ref="a281b09bc65fc43109563bff6d9e55995" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00104.html">InterfaceEntry</a> * InterfaceTable::getInterfaceByNodeOutputGateId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an interface given by its getNodeOutputGateId(). Returns NULL if not found. </p>

<p>Implements <a class="el" href="a00100.html#a31ab0c95a4bf741f1f8aa03e1cf76986">IInterfaceTable</a>.</p>

<p>Referenced by <a class="el" href="a00106.html#a109c3bcfee676b91628bef4582839f50">getInterfaceByInterfaceModule()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// linear search is OK because normally we have don&#39;t have many interfaces and this func is rarely called</span>
    Enter_Method_Silent();
    <span class="keywordtype">int</span> n = idToInterface.size();
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)
        <span class="keywordflow">if</span> (idToInterface[i] &amp;&amp; idToInterface[i]-&gt;getNodeOutputGateId()==<span class="keywordtype">id</span>)
            <span class="keywordflow">return</span> idToInterface[i];
    <span class="keywordflow">return</span> NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa7bbc08564b199d7820f9fb5dafedead"></a><!-- doxytag: member="InterfaceTable::getNumInterfaces" ref="aa7bbc08564b199d7820f9fb5dafedead" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int InterfaceTable::getNumInterfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the number of interfaces. </p>

<p>Implements <a class="el" href="a00100.html#a2b0ce46cd92da6f64fc363410dc71904">IInterfaceTable</a>.</p>

<p>Referenced by <a class="el" href="a00106.html#a20068628e72377ed78735e6b008a0a9f">getInterface()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (tmpNumInterfaces == -1)
    {
        <span class="comment">// count non-NULL elements</span>
        <span class="keywordtype">int</span> n = 0;
        <span class="keywordtype">int</span> maxId = idToInterface.size();
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;maxId; i++)
            <span class="keywordflow">if</span> (idToInterface[i])
                n++;
        tmpNumInterfaces = n;
    }

    <span class="keywordflow">return</span> tmpNumInterfaces;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a101a52971a1de7df6479a3412ec5940c"></a><!-- doxytag: member="InterfaceTable::handleMessage" ref="a101a52971a1de7df6479a3412ec5940c" args="(cMessage *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InterfaceTable::handleMessage </td>
          <td>(</td>
          <td class="paramtype">cMessage *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Raises an error. </p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">throw</span> cRuntimeError(<span class="stringliteral">&quot;This module doesn&#39;t process messages&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a70303b94020a300c74222695a2cfa261"></a><!-- doxytag: member="InterfaceTable::receiveChangeNotification" ref="a70303b94020a300c74222695a2cfa261" args="(int category, const cObject *details)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InterfaceTable::receiveChangeNotification </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cObject *&#160;</td>
          <td class="paramname"><em>details</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by the <a class="el" href="a00164.html">NotificationBoard</a> whenever a change of a category occurs to which this client has subscribed. </p>

<p>Implements <a class="el" href="a00102.html#a26809ed59b2ff3e9379b1b4440227a8d">INotifiable</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// nothing needed here at the moment</span>
    Enter_Method_Silent();
    printNotificationBanner(category, details);
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Projects/MiXiM/extsrc/mixim/src/inet_stub/networklayer/common/<a class="el" href="a00390_source.html">InterfaceTable.h</a></li>
<li>D:/Projects/MiXiM/extsrc/mixim/src/inet_stub/networklayer/common/InterfaceTable.cc</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00106.html">InterfaceTable</a>      </li>

    <li class="footer">Generated on Tue Mar 5 2013 21:26:32 for MiXiM by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
