<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MiXiM
   &#160;<span id="projectnumber">2.3</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00057.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00520.html">mappingDetails - mostly internal mapping classes</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ConstInterpolateableIterator" -->
<p>Template for an interpolateable const iterator for any container which maps from a key to a value. This doesn't necessarily has to be a map, but also can be a sorted list of pairs.  
 <a href="a00057.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00293_source.html">Interpolation.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a00661.png" border="0" usemap="#ConstInterpolateableIterator_3_01__Interpolator_00_01__IteratorType_01_4_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a00662.png" border="0" usemap="#ConstInterpolateableIterator_3_01__Interpolator_00_01__IteratorType_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00663.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ceb4238f825dc152217058c0c7dc001"></a><!-- doxytag: member="ConstInterpolateableIterator::interpolator_type" ref="a1ceb4238f825dc152217058c0c7dc001" args="" -->
typedef _Interpolator&#160;</td><td class="memItemRight" valign="bottom"><b>interpolator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50b68c37524eff1e40fc9b9977476e7d"></a><!-- doxytag: member="ConstInterpolateableIterator::container_type" ref="a50b68c37524eff1e40fc9b9977476e7d" args="" -->
typedef <br class="typebreak"/>
interpolator_type::container_type&#160;</td><td class="memItemRight" valign="bottom"><b>container_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad73c5dcc647fa3b7a84763a954fe11bb"></a><!-- doxytag: member="ConstInterpolateableIterator::key_type" ref="ad73c5dcc647fa3b7a84763a954fe11bb" args="" -->
typedef interpolator_type::key_type&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c972215632186ddedcda88204012353"></a><!-- doxytag: member="ConstInterpolateableIterator::key_cref_type" ref="a2c972215632186ddedcda88204012353" args="" -->
typedef <br class="typebreak"/>
interpolator_type::key_cref_type&#160;</td><td class="memItemRight" valign="bottom"><b>key_cref_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d498cb8110907ecc04a5a9a005db9ed"></a><!-- doxytag: member="ConstInterpolateableIterator::mapped_type" ref="a0d498cb8110907ecc04a5a9a005db9ed" args="" -->
typedef <br class="typebreak"/>
interpolator_type::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c3a2627837864de9aa91b7a8ba4c815"></a><!-- doxytag: member="ConstInterpolateableIterator::mapped_cref_type" ref="a5c3a2627837864de9aa91b7a8ba4c815" args="" -->
typedef <br class="typebreak"/>
interpolator_type::mapped_cref_type&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_cref_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11cdbe76ac12b7479f1c4697131f6dd1"></a><!-- doxytag: member="ConstInterpolateableIterator::pair_type" ref="a11cdbe76ac12b7479f1c4697131f6dd1" args="" -->
typedef <br class="typebreak"/>
interpolator_type::pair_type&#160;</td><td class="memItemRight" valign="bottom"><b>pair_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a524823dbf762366cded5cfe2ccca2939"></a><!-- doxytag: member="ConstInterpolateableIterator::iterator" ref="a524823dbf762366cded5cfe2ccca2939" args="" -->
typedef interpolator_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7539b5f9b0b46a26a33d1f1c22845084"></a><!-- doxytag: member="ConstInterpolateableIterator::const_iterator" ref="a7539b5f9b0b46a26a33d1f1c22845084" args="" -->
typedef <br class="typebreak"/>
interpolator_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7de2ff003436372e26b57596da13b8c3"></a><!-- doxytag: member="ConstInterpolateableIterator::comparator_type" ref="a7de2ff003436372e26b57596da13b8c3" args="" -->
typedef <br class="typebreak"/>
interpolator_type::comparator_type&#160;</td><td class="memItemRight" valign="bottom"><b>comparator_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad651c523db58df483cb6a3369406ef22"></a><!-- doxytag: member="ConstInterpolateableIterator::used_iterator" ref="ad651c523db58df483cb6a3369406ef22" args="" -->
typedef _IteratorType&#160;</td><td class="memItemRight" valign="bottom"><b>used_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ed1c02edab5e7153ef4d29f26e57216"></a><!-- doxytag: member="ConstInterpolateableIterator::interpolated" ref="a5ed1c02edab5e7153ef4d29f26e57216" args="" -->
typedef <br class="typebreak"/>
interpolator_type::interpolated&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a5ed1c02edab5e7153ef4d29f26e57216">interpolated</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for the returned <a class="el" href="a00111.html" title="Represents an interpolated value of any type.">Interpolated</a> value of this class. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7376c0555d5afa5e51e5fef70d32d2b"></a><!-- doxytag: member="ConstInterpolateableIterator::ConstInterpolateableIterator" ref="af7376c0555d5afa5e51e5fef70d32d2b" args="(const used_iterator &amp;first, const used_iterator &amp;last, const interpolator_type &amp;intpl)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#af7376c0555d5afa5e51e5fef70d32d2b">ConstInterpolateableIterator</a> (const used_iterator &amp;first, const used_iterator &amp;last, const interpolator_type &amp;intpl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the iterator with the passed Iterators as boundaries. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cbe300c6f575e24a8ab9ab269cac8ff"></a><!-- doxytag: member="ConstInterpolateableIterator::operator==" ref="a4cbe300c6f575e24a8ab9ab269cac8ff" args="(const ConstInterpolateableIterator &amp;other)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00057.html">ConstInterpolateableIterator</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad149b5c37b429ccc1fc5615c217cd3de"></a><!-- doxytag: member="ConstInterpolateableIterator::jumpTo" ref="ad149b5c37b429ccc1fc5615c217cd3de" args="(key_cref_type pos)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ad149b5c37b429ccc1fc5615c217cd3de">jumpTo</a> (key_cref_type pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator to the passed position. This position can be any value of the Key-type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a812d4bd2ab7b419deb933b8c472e1912"></a><!-- doxytag: member="ConstInterpolateableIterator::jumpToBegin" ref="a812d4bd2ab7b419deb933b8c472e1912" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a812d4bd2ab7b419deb933b8c472e1912">jumpToBegin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator to the first element. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a0a190c448a5cfbcd3385c6ccd316542f">iterateTo</a> (key_cref_type pos)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">forward iterates the iterator to the passed position. This position can be any value of the Key-type.  <a href="#a0a190c448a5cfbcd3385c6ccd316542f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#aa9b9aaf1491ef6ef251bc7399aecdf52">next</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates to the next entry in the underlying data structure.  <a href="#aa9b9aaf1491ef6ef251bc7399aecdf52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa545c5da980cbc9a5889ac6cf42d7b7e"></a><!-- doxytag: member="ConstInterpolateableIterator::getNextPosition" ref="aa545c5da980cbc9a5889ac6cf42d7b7e" args="()" -->
key_type&#160;</td><td class="memItemRight" valign="bottom"><b>getNextPosition</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eca971338ae67b5ee34503cbcf1f342"></a><!-- doxytag: member="ConstInterpolateableIterator::inRange" ref="a4eca971338ae67b5ee34503cbcf1f342" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a4eca971338ae67b5ee34503cbcf1f342">inRange</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current position of the iterator is between the position of the first and the last entry of the data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4906a4e7a03086a28d108fc262faa969"></a><!-- doxytag: member="ConstInterpolateableIterator::hasNext" ref="a4906a4e7a03086a28d108fc262faa969" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a4906a4e7a03086a28d108fc262faa969">hasNext</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the a call of "next()" would increase to the position of an a valid entry of the data structure. This means if the current position is smaller than position of the last entry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00057.html#a5ed1c02edab5e7153ef4d29f26e57216">interpolated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#afd052facfd07e1a139a6da76d129917e">getValue</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interpolated value at the current position of the Iterator.  <a href="#afd052facfd07e1a139a6da76d129917e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca4c6576c12ffd03107960a356e76326"></a><!-- doxytag: member="ConstInterpolateableIterator::getNextValue" ref="aca4c6576c12ffd03107960a356e76326" args="() const " -->
<a class="el" href="a00057.html#a5ed1c02edab5e7153ef4d29f26e57216">interpolated</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNextValue</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8b162ab907fbc33e47db214f28518a"></a><!-- doxytag: member="ConstInterpolateableIterator::getPosition" ref="a2d8b162ab907fbc33e47db214f28518a" args="() const " -->
key_cref_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a2d8b162ab907fbc33e47db214f28518a">getPosition</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current position of the iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e45b990b544290f7a0dd1a8155c4978"></a><!-- doxytag: member="ConstInterpolateableIterator::getInterpolator" ref="a9e45b990b544290f7a0dd1a8155c4978" args="() const " -->
const interpolator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInterpolator</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3720bcb63a64de42e4b16cb86df2bb77"></a><!-- doxytag: member="ConstInterpolateableIterator::first" ref="a3720bcb63a64de42e4b16cb86df2bb77" args="" -->
used_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>first</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15720a496cb3f3942707583ef80db5a2"></a><!-- doxytag: member="ConstInterpolateableIterator::last" ref="a15720a496cb3f3942707583ef80db5a2" args="" -->
used_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>last</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bb5e64387644bd21ca8345e15f5bcd1"></a><!-- doxytag: member="ConstInterpolateableIterator::right" ref="a4bb5e64387644bd21ca8345e15f5bcd1" args="" -->
used_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>right</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22d17fb7ce4b73648b28e62b34292382"></a><!-- doxytag: member="ConstInterpolateableIterator::position" ref="a22d17fb7ce4b73648b28e62b34292382" args="" -->
key_type&#160;</td><td class="memItemRight" valign="bottom"><b>position</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac41169286738eeb6ef050a87eb1ced3"></a><!-- doxytag: member="ConstInterpolateableIterator::interpolate" ref="aac41169286738eeb6ef050a87eb1ced3" args="" -->
const interpolator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>interpolate</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Interpolator, typename _IteratorType = typename _Interpolator::const_iterator&gt;<br/>
class ConstInterpolateableIterator&lt; _Interpolator, _IteratorType &gt;</h3>

<p>Template for an interpolateable const iterator for any container which maps from a key to a value. This doesn't necessarily has to be a map, but also can be a sorted list of pairs. </p>
<p>The <a class="el" href="a00057.html" title="Template for an interpolateable const iterator for any container which maps from a key to a value...">ConstInterpolateableIterator</a> provides an iterator which as able to iterate in arbitrary steps over a iterateable number of pairs of "Key" and "Value". To determine the Value for a Key which does not exist in within the iterateable number of pairs it Interpolates between the nearby existing pairs. The actual Interpolation is determined by the passed Interpolator-template parameter.</p>
<p>An example use would be to be able to iterate over a std::map&lt;double, double&gt; in arbitrary steps (even at positions for which no Key exist inside the map) and be able to return an interpolated Value.</p>
<p>NOTE: The <a class="el" href="a00057.html" title="Template for an interpolateable const iterator for any container which maps from a key to a value...">ConstInterpolateableIterator</a> will become invalid if the underlying data structure is changed!</p>
<p>Template parameters: Pair - the type of the pair used as values in the container. Default is std::map&lt;Key, V&gt;::value_type (which is of type std::pair&lt;Key, V&gt;. The Pair type has to provide the two public members "first" and "second". Key - The type of the "first" member of the Pair type V - the type of the "second" member of the Pair type Iterator - the type of the iterator of the container (should be a const iterator). Default is std::map&lt;Key, V&gt;::const_iterator Interpolator - The Interpolation operator to use, this has to be a class which overwrites the ()-operator with the following parameters: <a class="el" href="a00111.html" title="Represents an interpolated value of any type.">Interpolated</a> operator()(const Iterator&amp; first, const Iterator&amp; last, const Key&amp; pos) <a class="el" href="a00111.html" title="Represents an interpolated value of any type.">Interpolated</a> operator()(const Iterator&amp; first, const Iterator&amp; last, const Key&amp; pos, Iterator upperBound) See the <a class="el" href="a00158.html" title="Given two iterators defining a range of key-value-pairs this class provides interpolation of values f...">NextSmaller</a> template for an example of an Interpolator. Default is NextSmaller&lt;Key, V, Pair, Iterator&gt;.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Karl Wessel </dd></dl>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afd052facfd07e1a139a6da76d129917e"></a><!-- doxytag: member="ConstInterpolateableIterator::getValue" ref="afd052facfd07e1a139a6da76d129917e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Interpolator, typename _IteratorType = typename _Interpolator::const_iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00057.html#a5ed1c02edab5e7153ef4d29f26e57216">interpolated</a> <a class="el" href="a00057.html">ConstInterpolateableIterator</a>&lt; _Interpolator, _IteratorType &gt;::getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the interpolated value at the current position of the Iterator. </p>
<p>See definition of <a class="el" href="a00111.html" title="Represents an interpolated value of any type.">Interpolated</a> on details on the return type. </p>

<p>Referenced by <a class="el" href="a00149.html#a916ccca90ebffc95897f6c13bda9dd67">MultiDimMappingIterator&lt; Linear &gt;::MultiDimMappingIterator()</a>, and <a class="el" href="a00149.html#a48c928d79af27bc468eb50cc24d15a38">MultiDimMappingIterator&lt; Linear &gt;::updateSubIterator()</a>.</p>
<div class="fragment"><pre class="fragment">                               {
    <span class="keywordflow">return</span> interpolate(first, last, position, right);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a0a190c448a5cfbcd3385c6ccd316542f"></a><!-- doxytag: member="ConstInterpolateableIterator::iterateTo" ref="a0a190c448a5cfbcd3385c6ccd316542f" args="(key_cref_type pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Interpolator, typename _IteratorType = typename _Interpolator::const_iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00057.html">ConstInterpolateableIterator</a>&lt; _Interpolator, _IteratorType &gt;::iterateTo </td>
          <td>(</td>
          <td class="paramtype">key_cref_type&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>forward iterates the iterator to the passed position. This position can be any value of the Key-type. </p>
<p>This method assumes that the passed position is near the current position of the iterator. If this is the case this method will be faster than the jumpTo-method. </p>

<p>Referenced by <a class="el" href="a00149.html#a3a3b5ddc5aa1636772b9a89c085acdfc">MultiDimMappingIterator&lt; Linear &gt;::iterateTo()</a>.</p>
<div class="fragment"><pre class="fragment">                                    {
    <span class="keywordflow">if</span>(pos == position)
      <span class="keywordflow">return</span>;

    <span class="keywordflow">while</span>(right != last &amp;&amp; !(pos &lt; right-&gt;first))
      ++right;

    position = pos;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="aa9b9aaf1491ef6ef251bc7399aecdf52"></a><!-- doxytag: member="ConstInterpolateableIterator::next" ref="aa9b9aaf1491ef6ef251bc7399aecdf52" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Interpolator, typename _IteratorType = typename _Interpolator::const_iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00057.html">ConstInterpolateableIterator</a>&lt; _Interpolator, _IteratorType &gt;::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates to the next entry in the underlying data structure. </p>
<p>If the current position is before the position of the first element of the data structure this method will iterate to the first entry. If the current position is after the position of the last element of the data structure this method will increase the current position with the ++ operator. </p>

<p>Referenced by <a class="el" href="a00149.html#a8928195a1fe4bb3af81d3ffe2391827e">MultiDimMappingIterator&lt; Linear &gt;::next()</a>.</p>
<div class="fragment"><pre class="fragment">              {
    <span class="keywordflow">if</span>(<a class="code" href="a00057.html#a4906a4e7a03086a28d108fc262faa969" title="Returns true if the a call of &quot;next()&quot; would increase to the position of an a valid entry of the data...">hasNext</a>()) {
      position = right-&gt;first;
      ++right;
    } <span class="keywordflow">else</span>
      position += 1;
  }
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/Projects/MiXiM/extsrc/mixim/src/base/phyLayer/<a class="el" href="a00293_source.html">Interpolation.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00057.html">ConstInterpolateableIterator</a>      </li>

    <li class="footer">Generated on Tue Mar 5 2013 21:26:31 for MiXiM by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
