<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: PostureTransition Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MiXiM
   &#160;<span id="projectnumber">2.3</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00179.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PostureTransition Class Reference<div class="ingroups"><a class="el" href="a00513.html">mobility - modules handling the mobility of the hosts</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PostureTransition" -->
<p>Class to provide spatial and temporal correlation in the posture selection process of the MoBAN mobility model. This class obtains and stores Markovian transition matrices. There is also the possibility to get a steady state vector. In this case, the closest transition matrix to the default Makov matrix is extracted which satisfies the given steady state vector. The class also receives the defined area types and time domains as well as given space-time domains during the initialization phase. During the simulation run, the class provide a functions to return the corresponding markov matrix for a given time and location. It will be used whenever a new posture is going to be selected.  
 <a href="a00179.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00371_source.html">PostureTransition.h</a>&gt;</code></p>

<p><a href="a00946.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">AreaBound</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for one instance of the area (space) boundary.  <a href="a00011.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">AreaType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for one instance of area type.  <a href="a00012.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">CombinationType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for one instance of space-time combination.  <a href="a00048.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">TimeBound</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for one instance of the time boundary.  <a href="a00210.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">TimeDomainType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for one instance of time domain.  <a href="a00211.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">TransMatrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for one instance of Markov transition matrix.  <a href="a00218.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a4b10c46a88e6be413c7395c06bf65380">PostureTransition</a> (int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a posture transition object. The parameter is the number of postures which is the dimension of all matrices.  <a href="#a4b10c46a88e6be413c7395c06bf65380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a2f02ecf5282c7bd2f124a814c9abaa47">addMatrix</a> (std::string, double **, bool)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a transition matrix and add to the list.  <a href="#a2f02ecf5282c7bd2f124a814c9abaa47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#ac5c424a8372a3d6f39ccc06c88d4249f">addSteadyState</a> (std::string, double *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a steady state vector, extracts the corresponding transition matrix considering the default matrix, and add to the list of given matrices.  <a href="#ac5c424a8372a3d6f39ccc06c88d4249f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a261ad915b2a9c7cdf7082660360190e4">addAreaType</a> (std::string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a area type to the list with the given name and returns the index of this area type in the list.  <a href="#a261ad915b2a9c7cdf7082660360190e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a309ed6acf7eca6469f0ea0f06ee41780">setAreaBoundry</a> (int, <a class="el" href="a00065.html">Coord</a>, <a class="el" href="a00065.html">Coord</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given boundary to the existing area type specified by the given ID .  <a href="#a309ed6acf7eca6469f0ea0f06ee41780"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a58c7924dfb8810ba37311217a7ba5c8d">addTimeDomain</a> (std::string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a time domain to the list with the given name and returns the index of the this time domain in the list.  <a href="#a58c7924dfb8810ba37311217a7ba5c8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#af66d8f9dda835d55dc3009cf582f87d8">setTimeBoundry</a> (int, simtime_t, simtime_t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given boundary to the existing time domain specified by the given ID .  <a href="#af66d8f9dda835d55dc3009cf582f87d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a5b4ab00961c0039aac63143d28e88272">addCombination</a> (std::string, std::string, std::string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a space-time combination to the list.  <a href="#a5b4ab00961c0039aac63143d28e88272"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a1f04b24b643026f15fbc95d175429c5f">getMatrix</a> (simtime_t, <a class="el" href="a00065.html">Coord</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a time and location, and returns the corresponding Markov transition matrix.  <a href="#a1f04b24b643026f15fbc95d175429c5f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9e0f2800e1fa2b681ed55c07eb8046"></a><!-- doxytag: member="PostureTransition::TransMatrixList" ref="a7c9e0f2800e1fa2b681ed55c07eb8046" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00218.html">TransMatrix</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a7c9e0f2800e1fa2b681ed55c07eb8046">TransMatrixList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for a list of Markov transition matrices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98b2ed7203b32614bd82d29079db59cc"></a><!-- doxytag: member="PostureTransition::AreaTypeList" ref="a98b2ed7203b32614bd82d29079db59cc" args="" -->
typedef std::vector&lt; <a class="el" href="a00012.html">AreaType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a98b2ed7203b32614bd82d29079db59cc">AreaTypeList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for the list of area types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867c3cd2530e28d6f2953508a700ffec"></a><!-- doxytag: member="PostureTransition::TimeDomainList" ref="a867c3cd2530e28d6f2953508a700ffec" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00211.html">TimeDomainType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a867c3cd2530e28d6f2953508a700ffec">TimeDomainList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for the list of time domains. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03a03987992fffd49db8174cf6e83953"></a><!-- doxytag: member="PostureTransition::CombinationList" ref="a03a03987992fffd49db8174cf6e83953" args="" -->
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00048.html">CombinationType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a03a03987992fffd49db8174cf6e83953">CombinationList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for the list of space-time combinations. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a3ddddcbf58ad8e1edd23cf8023c7b974">extractMatrixFromSteadyState</a> (double *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a steady state vector and return a matrix which is as close as posible to the default matrix and satisfies the given steady state.  <a href="#a3ddddcbf58ad8e1edd23cf8023c7b974"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#ae252301f9e6668f04fad293321f55066">findTimeDomain</a> (simtime_t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a time and finds the ID of the containing time domain if there is. If not, return -1.  <a href="#ae252301f9e6668f04fad293321f55066"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a299b33afdc27f467b3cdd472a397bb5a">findAreaType</a> (<a class="el" href="a00065.html">Coord</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a location and finds the ID of the containing area type if there is. If not, return -1.  <a href="#a299b33afdc27f467b3cdd472a397bb5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#abe806a2afdeb239694094c24446f699f">isMarkovian</a> (double **)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a matrix can be a Markov transition matrix. All elements should be in the range [0,1] and elements of each column of the matrix should add up to 1.  <a href="#abe806a2afdeb239694094c24446f699f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a67a8cc00702db7106fc5b38447398856">isMarkovian</a> (double *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a vector can be the steady state of a Markov chain. All elements should be in the range [0,1] and the sum of elements should be 1.  <a href="#a67a8cc00702db7106fc5b38447398856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#abe7336508b8864deeb66872425662587">multMatrix</a> (double **, double **, double **)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two matrices with dimension numPos*numPose .  <a href="#abe7336508b8864deeb66872425662587"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a10abfb612543bbc52f6a13a0e138d822">addMatrix</a> (double **, double **, double **)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two matrices with dimension numPos*numPose .  <a href="#a10abfb612543bbc52f6a13a0e138d822"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#af48e8ee3a857b2425a9f1fe6ded08841">subtractMatrix</a> (double **, double **, double **)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two matrices with dimension numPos*numPose .  <a href="#af48e8ee3a857b2425a9f1fe6ded08841"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a2781afe68489f9278e755429787b22ec">multVector</a> (double *, double **)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector of size numPos with its transpose.  <a href="#a2781afe68489f9278e755429787b22ec"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88d4a9fb3d68fb6792ebade157067d73"></a><!-- doxytag: member="PostureTransition::numPos" ref="a88d4a9fb3d68fb6792ebade157067d73" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of postures. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae24e4f7a9dc7453d935b87669a0edf24"></a><!-- doxytag: member="PostureTransition::defaultMatrixID" ref="ae24e4f7a9dc7453d935b87669a0edf24" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24">defaultMatrixID</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the default (base) transition matrix. If no default is set, the first matrix is supposed as the default. Default matrix is used for the cases that a time or space domain does not lie in any given area types or time domains. It is also used for generating the transition matrix in the case that a steady state vector is given for a space-time domain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16d12fd657a13f5a43f5b9d1dd6fea7a"></a><!-- doxytag: member="PostureTransition::matrixList" ref="a16d12fd657a13f5a43f5b9d1dd6fea7a" args="" -->
<a class="el" href="a00179.html#a7c9e0f2800e1fa2b681ed55c07eb8046">TransMatrixList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a">matrixList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of all given transition matrices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438b1e6813a28c3b9b49ae4ecef1b937"></a><!-- doxytag: member="PostureTransition::areaTypeList" ref="a438b1e6813a28c3b9b49ae4ecef1b937" args="" -->
<a class="el" href="a00179.html#a98b2ed7203b32614bd82d29079db59cc">AreaTypeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937">areaTypeList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of all defined area types. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0566260a55d34fde7d6e35103f95785a"></a><!-- doxytag: member="PostureTransition::timeDomainList" ref="a0566260a55d34fde7d6e35103f95785a" args="" -->
<a class="el" href="a00179.html#a867c3cd2530e28d6f2953508a700ffec">TimeDomainList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#a0566260a55d34fde7d6e35103f95785a">timeDomainList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of all defined time domains. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4afd59bcc62d7e198bebff13c873746"></a><!-- doxytag: member="PostureTransition::combinationList" ref="ab4afd59bcc62d7e198bebff13c873746" args="" -->
<a class="el" href="a00179.html#a03a03987992fffd49db8174cf6e83953">CombinationList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html#ab4afd59bcc62d7e198bebff13c873746">combinationList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of all given space-time combinations. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Class to provide spatial and temporal correlation in the posture selection process of the MoBAN mobility model. This class obtains and stores Markovian transition matrices. There is also the possibility to get a steady state vector. In this case, the closest transition matrix to the default Makov matrix is extracted which satisfies the given steady state vector. The class also receives the defined area types and time domains as well as given space-time domains during the initialization phase. During the simulation run, the class provide a functions to return the corresponding markov matrix for a given time and location. It will be used whenever a new posture is going to be selected. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Majid Nabi </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4b10c46a88e6be413c7395c06bf65380"></a><!-- doxytag: member="PostureTransition::PostureTransition" ref="a4b10c46a88e6be413c7395c06bf65380" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostureTransition::PostureTransition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPosture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a posture transition object. The parameter is the number of postures which is the dimension of all matrices. </p>
<p>Constructor function of the class. It sets the value for t he number of posture. It also suppose the first given transition matrix as default. However, during parsing the xml configuration file, if a matrix has attribute type with value "default", it will be considered as the default (base) transition matrix. </p>

<p>References <a class="el" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24">defaultMatrixID</a>, and <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> = numPosture;
    <a class="code" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first matrix is supposed...">defaultMatrixID</a> = 0; <span class="comment">// if no default matrix found, the first one will be supposed as the default matrix.</span>
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a261ad915b2a9c7cdf7082660360190e4"></a><!-- doxytag: member="PostureTransition::addAreaType" ref="a261ad915b2a9c7cdf7082660360190e4" args="(std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addAreaType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a area type to the list with the given name and returns the index of this area type in the list. </p>
<p>Creates a new area type instance and adds it to the list. The boundaries of the area type is empty now. It will be filled later. The function returns the index of the new area type in the list as its output. </p>

<p>References <a class="el" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937">areaTypeList</a>.</p>

<p>Referenced by <a class="el" href="a00142.html#a138ebd67882d6cf1154126f47d35d49c">MoBANCoordinator::readConfigurationFile()</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="comment">//Check if the name is repetitive</span>
    AreaTypeList::const_iterator areaIt;
    <span class="keywordflow">for</span> (areaIt = <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
    {
        <span class="keywordflow">if</span> ((*areaIt)-&gt;name == name )
        {
            std::string str = <span class="stringliteral">&quot;There are multiple area types with the same name: &quot;</span> + name + <span class="stringliteral">&quot; in the configuration file!&quot;</span>;
            opp_error (str.c_str());
        }
    }

    AreaType* area = <span class="keyword">new</span> AreaType;
    area-&gt;name = name;
    <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.push_back(area);
    <span class="keywordflow">return</span> <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.size()-1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5b4ab00961c0039aac63143d28e88272"></a><!-- doxytag: member="PostureTransition::addCombination" ref="a5b4ab00961c0039aac63143d28e88272" args="(std::string, std::string, std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::addCombination </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>areaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>timeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>matrixName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a space-time combination to the list. </p>
<p>This function creates a new space-time combination instance and adds it to the combinations list. It checks if the given names for area type, time domain, and matrix are previously defined and exist in the corresponding lists. Note that at least area type or time domain should have been specified for a combination. Otherwise the combination is not meaningful. if for example a combination has no area type and just has specified time domain, it means that for the whole simulation area, it will be the same and the proper matrix is selected based on the time. </p>

<p>References <a class="el" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937">areaTypeList</a>, <a class="el" href="a00179.html#ab4afd59bcc62d7e198bebff13c873746">combinationList</a>, <a class="el" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a">matrixList</a>, and <a class="el" href="a00179.html#a0566260a55d34fde7d6e35103f95785a">timeDomainList</a>.</p>

<p>Referenced by <a class="el" href="a00142.html#a138ebd67882d6cf1154126f47d35d49c">MoBANCoordinator::readConfigurationFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> thisID;
    CombinationType* comb = <span class="keyword">new</span> CombinationType;
    comb-&gt;areaID = -1;
    comb-&gt;timeID = -1;
    comb-&gt;matrixID = -1;

    <span class="comment">// look for matching area type name.</span>
    thisID = 0;
    AreaTypeList::const_iterator areaIt;
    <span class="keywordflow">for</span> (areaIt = <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
    {
        <span class="keywordflow">if</span> (areaName == (*areaIt)-&gt;name )
        {
            comb-&gt;areaID = thisID;
            <span class="keywordflow">break</span>;
        }
        ++thisID;
    }

    <span class="comment">// in the input name is empty, it means that no area type is specified for this combination.</span>
    <span class="keywordflow">if</span> (comb-&gt;areaID == -1 &amp;&amp; !areaName.empty())
    {
        std::string str = <span class="stringliteral">&quot;Undefined area type name is given in a combinations: &quot;</span> + areaName + <span class="stringliteral">&quot;, &quot;</span> + timeName + <span class="stringliteral">&quot;, &quot;</span> + matrixName;
        opp_error (str.c_str());
    }


    <span class="comment">// look for matching time domain name.</span>
    thisID = 0;
    TimeDomainList::const_iterator timeIt;
    <span class="keywordflow">for</span> (timeIt = <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
    {
        <span class="keywordflow">if</span> (timeName == (*timeIt)-&gt;name )
        {
            comb-&gt;timeID = thisID;
            <span class="keywordflow">break</span>;
        }
        ++thisID;
    }
    <span class="keywordflow">if</span> (comb-&gt;timeID == -1 &amp;&amp; !timeName.empty())
    {
        std::string str = <span class="stringliteral">&quot;Undefined time domain name is given in a combinations: &quot;</span> + areaName + <span class="stringliteral">&quot;, &quot;</span> + timeName + <span class="stringliteral">&quot;, &quot;</span> + matrixName;
        opp_error (str.c_str());
    }


    <span class="keywordflow">if</span> (comb-&gt;areaID == -1 &amp;&amp; comb-&gt;timeID == -1)
        opp_error (<span class="stringliteral">&quot;Both area type and time domain is unspecified in a combination.&quot;</span> );

    <span class="comment">// look for matching transition matrix name.</span>
    thisID = 0;
    TransMatrixList::const_iterator matrixIt;
    <span class="keywordflow">for</span> (matrixIt = <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
    {
        <span class="keywordflow">if</span> (matrixName == (*matrixIt)-&gt;name )
        {
            comb-&gt;matrixID = thisID;
            <span class="keywordflow">break</span>;
        }
        ++thisID;
    }
    <span class="keywordflow">if</span> (comb-&gt;matrixID == -1)
        opp_error (<span class="stringliteral">&quot;Undefined matrix name is given in the combinations&quot;</span> );

    <a class="code" href="a00179.html#ab4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.push_back(comb);

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a10abfb612543bbc52f6a13a0e138d822"></a><!-- doxytag: member="PostureTransition::addMatrix" ref="a10abfb612543bbc52f6a13a0e138d822" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::addMatrix </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds two matrices with dimension numPos*numPose . </p>
<p>Function to add two matrix with the known dimensions as number of postures. </p>

<p>References <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00179.html#a3ddddcbf58ad8e1edd23cf8023c7b974">extractMatrixFromSteadyState()</a>, and <a class="el" href="a00142.html#a138ebd67882d6cf1154126f47d35d49c">MoBANCoordinator::readConfigurationFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i,j;
    <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
    {
        <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; j++)
            res[i][j] = mat1[i][j] + mat2[i][j];
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a2f02ecf5282c7bd2f124a814c9abaa47"></a><!-- doxytag: member="PostureTransition::addMatrix" ref="a2f02ecf5282c7bd2f124a814c9abaa47" args="(std::string, double **, bool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addMatrix </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>thisDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives a transition matrix and add to the list. </p>
<p>This function initiates a new instance of markov matrix with the given matrix. Note that it copies the matrix into the created matrix. The function first verifies if the given matrix can be a Markov transition matrix. </p>

<p>References <a class="el" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24">defaultMatrixID</a>, <a class="el" href="a00179.html#abe806a2afdeb239694094c24446f699f">isMarkovian()</a>, <a class="el" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a">matrixList</a>, and <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="comment">//check if the name is repetitive</span>
    TransMatrixList::const_iterator matrixIt;
    <span class="keywordflow">for</span> (matrixIt = <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
    {
        <span class="keywordflow">if</span> ((*matrixIt)-&gt;name == name )
        {
            std::string str = <span class="stringliteral">&quot;There are multiple matrices with the same name: &quot;</span> + name + <span class="stringliteral">&quot; in the configuration file!&quot;</span>;
            opp_error (str.c_str());
        }
    }


    <span class="comment">// verify if the given matrix is Markovian</span>
    <span class="keywordflow">if</span> ( !<a class="code" href="a00179.html#abe806a2afdeb239694094c24446f699f" title="Checks if a matrix can be a Markov transition matrix. All elements should be in the range [0...">isMarkovian</a>(matrix) )
    {
        std::string str = <span class="stringliteral">&quot;Given transition matrix &quot;</span> + name + <span class="stringliteral">&quot; is not Markovian!&quot;</span>;
        opp_error (str.c_str());
    }

    TransMatrix* mat = <span class="keyword">new</span> TransMatrix;

    mat-&gt;name = name;
    mat-&gt;matrix = <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
    {
        mat-&gt;matrix[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++j)
            mat-&gt;matrix[i][j] = matrix[i][j];
    }

    <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.push_back(mat);

    <span class="keywordflow">if</span> (thisDefault)
        <a class="code" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first matrix is supposed...">defaultMatrixID</a> = <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.size()-1;

    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac5c424a8372a3d6f39ccc06c88d4249f"></a><!-- doxytag: member="PostureTransition::addSteadyState" ref="ac5c424a8372a3d6f39ccc06c88d4249f" args="(std::string, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addSteadyState </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>iVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives a steady state vector, extracts the corresponding transition matrix considering the default matrix, and add to the list of given matrices. </p>
<p>This function creates a new instance of markov matrix to be filled with a derived matrix from the given steady state vector. The function first verifies if the given vector can be a steady state vector. Then extracts a markov matrix based on that and adds it to the list of given matrices. </p>

<p>References <a class="el" href="a00179.html#a3ddddcbf58ad8e1edd23cf8023c7b974">extractMatrixFromSteadyState()</a>, <a class="el" href="a00179.html#abe806a2afdeb239694094c24446f699f">isMarkovian()</a>, <a class="el" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a">matrixList</a>, and <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00142.html#a138ebd67882d6cf1154126f47d35d49c">MoBANCoordinator::readConfigurationFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//check if the name is repetitive</span>
    TransMatrixList::const_iterator matrixIt;
    <span class="keywordflow">for</span> (matrixIt = <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
    {
        <span class="keywordflow">if</span> ((*matrixIt)-&gt;name == name )
        {
            std::string str = <span class="stringliteral">&quot;There are multiple matrices with the same name: &quot;</span> + name + <span class="stringliteral">&quot; in the configuration file!&quot;</span>;
            opp_error (str.c_str());
        }
    }

    <span class="comment">// check if the given matrix is Markovian</span>
    <span class="keywordflow">if</span> ( !<a class="code" href="a00179.html#abe806a2afdeb239694094c24446f699f" title="Checks if a matrix can be a Markov transition matrix. All elements should be in the range [0...">isMarkovian</a>(iVector) )
    {
        std::string str = <span class="stringliteral">&quot;Given steady state vector &quot;</span> + name + <span class="stringliteral">&quot; cannot be true!&quot;</span>;
        opp_error (str.c_str());
    }

    <span class="comment">// make a local copy of the input steady state vector</span>
    <span class="keywordtype">double</span> *steady = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; ++i)
        steady[i] = iVector[i];

    TransMatrix* mat = <span class="keyword">new</span> TransMatrix;
    mat-&gt;name = name;
    mat-&gt;matrix = <a class="code" href="a00179.html#a3ddddcbf58ad8e1edd23cf8023c7b974" title="Gets a steady state vector and return a matrix which is as close as posible to the default matrix and...">extractMatrixFromSteadyState</a>(steady);

    <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.push_back(mat);

    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a58c7924dfb8810ba37311217a7ba5c8d"></a><!-- doxytag: member="PostureTransition::addTimeDomain" ref="a58c7924dfb8810ba37311217a7ba5c8d" args="(std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addTimeDomain </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a time domain to the list with the given name and returns the index of the this time domain in the list. </p>
<p>Creates a new time domain instance and adds it to the list. The boundaries of the time domain is empty now. It will be filled later. The function returns the index of the time domain in the list as its output. </p>

<p>References <a class="el" href="a00179.html#a0566260a55d34fde7d6e35103f95785a">timeDomainList</a>.</p>

<p>Referenced by <a class="el" href="a00142.html#a138ebd67882d6cf1154126f47d35d49c">MoBANCoordinator::readConfigurationFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//Check if the name is repetitive</span>
    TimeDomainList::const_iterator timeIt;
    <span class="keywordflow">for</span> (timeIt = <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
    {
        <span class="keywordflow">if</span> ((*timeIt)-&gt;name == name )
        {
            std::string str = <span class="stringliteral">&quot;There are multiple time domains with the same name: &quot;</span> + name + <span class="stringliteral">&quot; in the configuration file!&quot;</span>;
            opp_error (str.c_str());
        }
    }

    TimeDomainType* time = <span class="keyword">new</span> TimeDomainType;
    time-&gt;name = name;
    <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.push_back(time);
    <span class="keywordflow">return</span> <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.size()-1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3ddddcbf58ad8e1edd23cf8023c7b974"></a><!-- doxytag: member="PostureTransition::extractMatrixFromSteadyState" ref="a3ddddcbf58ad8e1edd23cf8023c7b974" args="(double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** PostureTransition::extractMatrixFromSteadyState </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a steady state vector and return a matrix which is as close as posible to the default matrix and satisfies the given steady state. </p>
<p>This function receives a steady state vector and extracts a Markovian matrix which is as close as possible to the default markov matrix and satisfies the given steady state vector. </p>

<p>References <a class="el" href="a00179.html#a10abfb612543bbc52f6a13a0e138d822">addMatrix()</a>, <a class="el" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24">defaultMatrixID</a>, <a class="el" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a">matrixList</a>, <a class="el" href="a00179.html#abe7336508b8864deeb66872425662587">multMatrix()</a>, <a class="el" href="a00179.html#a2781afe68489f9278e755429787b22ec">multVector()</a>, <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>, and <a class="el" href="a00179.html#af48e8ee3a857b2425a9f1fe6ded08841">subtractMatrix()</a>.</p>

<p>Referenced by <a class="el" href="a00179.html#ac5c424a8372a3d6f39ccc06c88d4249f">addSteadyState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i,j;
    <span class="keywordtype">double</span>** dafaultMat;

    <span class="comment">//make output matrix and an identity matrix and a temp</span>
    <span class="keywordtype">double</span>** mat= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordtype">double</span>** temp1= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordtype">double</span>** temp2= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordtype">double</span>** temp3= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordtype">double</span>** identity = <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordtype">int</span>** change = <span class="keyword">new</span> <span class="keywordtype">int</span>* [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
    {
        mat[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
        temp1[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
        temp2[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
        temp3[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
        identity[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
        change[i] = <span class="keyword">new</span> <span class="keywordtype">int</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];

    }

    <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
        <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; j++)
            <span class="keywordflow">if</span> (i==j)
                identity[i][j] = 1;
            <span class="keywordflow">else</span>
                identity[i][j] = 0;


    <span class="keywordtype">double</span>* sum= <span class="keyword">new</span> <span class="keywordtype">double</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
    <span class="keywordtype">int</span>* changeSum= <span class="keyword">new</span> <span class="keywordtype">int</span> [<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];


    dafaultMat = <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(<a class="code" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first matrix is supposed...">defaultMatrixID</a>)-&gt;matrix;


    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> numTry=0;numTry&lt;400;++numTry)
    {
        <a class="code" href="a00179.html#af48e8ee3a857b2425a9f1fe6ded08841" title="Subtracts two matrices with dimension numPos*numPose .">subtractMatrix</a>(identity,dafaultMat,temp1);
        <a class="code" href="a00179.html#a2781afe68489f9278e755429787b22ec" title="Multiply a vector of size numPos with its transpose.">multVector</a>(vec,temp2);
        <a class="code" href="a00179.html#abe7336508b8864deeb66872425662587" title="Multiplies two matrices with dimension numPos*numPose .">multMatrix</a>(temp1,temp2,temp3);
        <a class="code" href="a00179.html#a10abfb612543bbc52f6a13a0e138d822" title="Adds two matrices with dimension numPos*numPose .">addMatrix</a>(dafaultMat,temp3,mat);

        <span class="comment">//remember if it has not changed</span>
        <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
            <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; j++)
                change[i][j] = 1;

        <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; j++)
            <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; i++)
            {
                <span class="keywordflow">if</span> ( mat[i][j] &lt; 0 ){
                    mat[i][j] = 0;
                    change[i][j]=0;
                }
                <span class="keywordflow">if</span> ( mat[i][j] &gt; 1 ){
                    mat[i][j] = 1;
                    change[i][j]=0;
                }
            }


        <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; j++)
        {
            sum[j] = 0;
            changeSum[j]=0;
            <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; i++)
            {
                sum[j] += mat[i][j];
                changeSum[j] += change[i][j];
            }
        }

        <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; j++)
            <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; i++)
            {
                <span class="keywordflow">if</span> (change[i][j] == 1)
                    mat[i][j] = mat[i][j]+ (1-sum[j])/changeSum[j];
            }

        dafaultMat = mat;
    }

    <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; j++)
        <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; i++)
        {
            <span class="keywordflow">if</span> ( mat[i][j] &lt; 0 )
                mat[i][j] = 0;
            <span class="keywordflow">if</span> ( mat[i][j] &gt; 1 )
                mat[i][j] = 1;
        }


    EV &lt;&lt; <span class="stringliteral">&quot;Generated Markov matrix from the steady state: &quot;</span>&lt;&lt; endl;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; ++k)
    {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f=0; f&lt;<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ;++f)
            EV &lt;&lt; mat[k][f]&lt;&lt;<span class="stringliteral">&quot;       &quot;</span>;
        EV &lt;&lt; endl;
    }

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
    {
        <span class="keyword">delete</span> temp1[i]; <span class="keyword">delete</span> temp2[i]; <span class="keyword">delete</span> temp3[i];
        <span class="keyword">delete</span> identity[i];
        <span class="keyword">delete</span> change[i];
    }
    <span class="keyword">delete</span> temp1; <span class="keyword">delete</span> temp2; <span class="keyword">delete</span> temp3;
    <span class="keyword">delete</span> identity;
    <span class="keyword">delete</span> change;
    <span class="keyword">delete</span> sum;
    <span class="keyword">delete</span> changeSum;


    <span class="keywordflow">return</span> mat;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a299b33afdc27f467b3cdd472a397bb5a"></a><!-- doxytag: member="PostureTransition::findAreaType" ref="a299b33afdc27f467b3cdd472a397bb5a" args="(Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::findAreaType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00065.html">Coord</a>&#160;</td>
          <td class="paramname"><em>iLocation</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a location and finds the ID of the containing area type if there is. If not, return -1. </p>
<p>Looks for the first containing area type for the given location. It return the Id of the found area type. If no area type is found which contains the given location, it returns -1. </p>

<p>References <a class="el" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937">areaTypeList</a>, and <a class="el" href="a00065.html#a7a42e29d7a15ed0b53e47137549e00a6">Coord::isInBoundary()</a>.</p>

<p>Referenced by <a class="el" href="a00179.html#a1f04b24b643026f15fbc95d175429c5f">getMatrix()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> locationID=0;
    AreaTypeList::const_iterator areaIt;
    <span class="keywordflow">for</span> (areaIt = <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
    {
        std::vector&lt;AreaBound*&gt; boundList = (*areaIt)-&gt;boundries;

        std::vector&lt;AreaBound*&gt;::const_iterator bound;
        <span class="keywordflow">for</span> (bound = boundList.begin(); bound != boundList.end(); bound++)
        {
            <span class="keywordflow">if</span> ( iLocation.<a class="code" href="a00065.html#a7a42e29d7a15ed0b53e47137549e00a6" title="Checks if this coordinate is inside a specified rectangle.">isInBoundary</a>( (*bound)-&gt;low ,(*bound)-&gt;high ) )
                <span class="keywordflow">return</span> locationID;
        }
        ++locationID;
    }
    EV &lt;&lt; <span class="stringliteral">&quot;Area Type not found&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae252301f9e6668f04fad293321f55066"></a><!-- doxytag: member="PostureTransition::findTimeDomain" ref="ae252301f9e6668f04fad293321f55066" args="(simtime_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::findTimeDomain </td>
          <td>(</td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>iTime</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a time and finds the ID of the containing time domain if there is. If not, return -1. </p>
<p>Looks for the first containing time domain for the given time instance. It return the Id of the found time domain. If no time domain is found which contains the given time instance, it returns -1. </p>

<p>References <a class="el" href="a00179.html#a0566260a55d34fde7d6e35103f95785a">timeDomainList</a>.</p>

<p>Referenced by <a class="el" href="a00179.html#a1f04b24b643026f15fbc95d175429c5f">getMatrix()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> timeID=0;
    TimeDomainList::const_iterator timeIt;
    <span class="keywordflow">for</span> (timeIt = <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
    {
        std::vector&lt;TimeBound*&gt; boundList = (*timeIt)-&gt;boundries;

        std::vector&lt;TimeBound*&gt;::const_iterator bound;
        <span class="keywordflow">for</span> (bound = boundList.begin(); bound != boundList.end(); bound++)
        {
            <span class="keywordflow">if</span> ( iTime &gt;= (*bound)-&gt;low &amp;&amp; iTime &lt; (*bound)-&gt;high)
                <span class="keywordflow">return</span> timeID;
        }
        ++timeID;
    }
    EV &lt;&lt; <span class="stringliteral">&quot;Time domain not found&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1f04b24b643026f15fbc95d175429c5f"></a><!-- doxytag: member="PostureTransition::getMatrix" ref="a1f04b24b643026f15fbc95d175429c5f" args="(simtime_t, Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** PostureTransition::getMatrix </td>
          <td>(</td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>iTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00065.html">Coord</a>&#160;</td>
          <td class="paramname"><em>iLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a time and location, and returns the corresponding Markov transition matrix. </p>
<p>This function is actually the main usage of this class. It gets a time instance and a location within the simulation area, and then looks for the first fitting combination. If found, it returns the specified Markov transition matrix for that combination as its output. If no combination is found, it returns the default matrix. </p>

<p>References <a class="el" href="a00179.html#ab4afd59bcc62d7e198bebff13c873746">combinationList</a>, <a class="el" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24">defaultMatrixID</a>, <a class="el" href="a00179.html#a299b33afdc27f467b3cdd472a397bb5a">findAreaType()</a>, <a class="el" href="a00179.html#ae252301f9e6668f04fad293321f55066">findTimeDomain()</a>, <a class="el" href="a00065.html#a86994bfa7096155d951abb03dcf30bf1">Coord::info()</a>, and <a class="el" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a">matrixList</a>.</p>

<p>Referenced by <a class="el" href="a00142.html#ab622d4b167d9d5dbc7529969a6688597">MoBANCoordinator::selectPosture()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> timeID,locationID,matrixID;

    timeID = <a class="code" href="a00179.html#ae252301f9e6668f04fad293321f55066" title="Gets a time and finds the ID of the containing time domain if there is. If not, return -1...">findTimeDomain</a>(iTime);
    locationID = <a class="code" href="a00179.html#a299b33afdc27f467b3cdd472a397bb5a" title="Gets a location and finds the ID of the containing area type if there is. If not, return -1...">findAreaType</a>(iLocation);


    matrixID = <a class="code" href="a00179.html#ae24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first matrix is supposed...">defaultMatrixID</a>;

    CombinationList::const_iterator combIt;
    <span class="keywordflow">for</span> (combIt = <a class="code" href="a00179.html#ab4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.begin(); combIt != <a class="code" href="a00179.html#ab4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.end(); combIt++)
    {
        <span class="keywordflow">if</span> ( (*combIt)-&gt;timeID == timeID &amp;&amp; (*combIt)-&gt;areaID == locationID)
        {
            matrixID = (*combIt)-&gt;matrixID;
            <span class="keywordflow">break</span>;
        }
    }

    EV &lt;&lt; <span class="stringliteral">&quot;The corresponding Markov matrix for time&quot;</span> &lt;&lt; iTime.dbl() &lt;&lt;<span class="stringliteral">&quot; and location &quot;</span> &lt;&lt; iLocation.<a class="code" href="a00065.html#a86994bfa7096155d951abb03dcf30bf1" title="Returns a string with the value of the coordinate.">info</a>() &lt;&lt; <span class="stringliteral">&quot; is: &quot;</span> &lt;&lt; <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(matrixID)-&gt;name &lt;&lt; endl;

    <span class="keywordflow">return</span> <a class="code" href="a00179.html#a16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(matrixID)-&gt;matrix;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abe806a2afdeb239694094c24446f699f"></a><!-- doxytag: member="PostureTransition::isMarkovian" ref="abe806a2afdeb239694094c24446f699f" args="(double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::isMarkovian </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a matrix can be a Markov transition matrix. All elements should be in the range [0,1] and elements of each column of the matrix should add up to 1. </p>
<p>Verifies if a matrix can be a Markovian transition matrix. Each element of the matrix should be in the range [0 1]. Further, all elements of each column should adds up to one. </p>

<p>References <a class="el" href="a00095.html#a38d2500887b49de2a2b5f8610f7ba6d1">FWMath::close()</a>, and <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00179.html#a2f02ecf5282c7bd2f124a814c9abaa47">addMatrix()</a>, and <a class="el" href="a00179.html#ac5c424a8372a3d6f39ccc06c88d4249f">addSteadyState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">double</span> sumCol;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++j)
    {
        sumCol = 0;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
        {
            <span class="keywordflow">if</span> (matrix[i][j] &lt; 0 || matrix[i][j] &gt; 1)
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            sumCol += matrix[i][j];
        }

        <span class="keywordflow">if</span> (!<a class="code" href="a00095.html#a38d2500887b49de2a2b5f8610f7ba6d1">FWMath::close</a>(sumCol , 1.0 ))
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a67a8cc00702db7106fc5b38447398856"></a><!-- doxytag: member="PostureTransition::isMarkovian" ref="a67a8cc00702db7106fc5b38447398856" args="(double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::isMarkovian </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a vector can be the steady state of a Markov chain. All elements should be in the range [0,1] and the sum of elements should be 1. </p>
<p>Verifies if a vector can be the steady state of a Markov model. Each element of the matrix should be in the range [0 1]. Further, the sum of all elements should be one. </p>

<p>References <a class="el" href="a00095.html#a38d2500887b49de2a2b5f8610f7ba6d1">FWMath::close()</a>, and <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">double</span> sumCol=0;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
    {
        <span class="keywordflow">if</span> (vec[i] &lt; 0 || vec[i]&gt; 1)
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        sumCol += vec[i];
    }

    <span class="keywordflow">if</span> ( !<a class="code" href="a00095.html#a38d2500887b49de2a2b5f8610f7ba6d1">FWMath::close</a>(sumCol , 1.0 ) )
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abe7336508b8864deeb66872425662587"></a><!-- doxytag: member="PostureTransition::multMatrix" ref="abe7336508b8864deeb66872425662587" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::multMatrix </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies two matrices with dimension numPos*numPose . </p>
<p>Function to multiply two matrix with the known dimensions as number of postures. </p>

<p>References <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00179.html#a3ddddcbf58ad8e1edd23cf8023c7b974">extractMatrixFromSteadyState()</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="keywordtype">int</span> i,j,l;
    <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
    {
        <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; j++)
        {
            res[i][j]=0;
            <span class="keywordflow">for</span>(l=0; l &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; l++)
                res[i][j] += mat1[i][l] * mat2[l][j];
        }
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a2781afe68489f9278e755429787b22ec"></a><!-- doxytag: member="PostureTransition::multVector" ref="a2781afe68489f9278e755429787b22ec" args="(double *, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::multVector </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a vector of size numPos with its transpose. </p>
<p>Function to multiply a vector by its transpose (pi . pi^T). The size in equal to the number of postures. </p>

<p>References <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00179.html#a3ddddcbf58ad8e1edd23cf8023c7b974">extractMatrixFromSteadyState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i,j;
    <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
    {
        <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; j++)
            res[i][j] = vec[i] * vec[j];
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a309ed6acf7eca6469f0ea0f06ee41780"></a><!-- doxytag: member="PostureTransition::setAreaBoundry" ref="a309ed6acf7eca6469f0ea0f06ee41780" args="(int, Coord, Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::setAreaBoundry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00065.html">Coord</a>&#160;</td>
          <td class="paramname"><em>lowBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00065.html">Coord</a>&#160;</td>
          <td class="paramname"><em>highBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the given boundary to the existing area type specified by the given ID . </p>
<p>This function gets an index of an existing area type and adds the given boundary to the boundary list of that area type. </p>

<p>References <a class="el" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937">areaTypeList</a>.</p>

<p>Referenced by <a class="el" href="a00142.html#a138ebd67882d6cf1154126f47d35d49c">MoBANCoordinator::readConfigurationFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    AreaBound* bound=<span class="keyword">new</span> AreaBound;
    bound-&gt;low = lowBound;
    bound-&gt;high = highBound;

    <a class="code" href="a00179.html#a438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.at(<span class="keywordtype">id</span>)-&gt;boundries.push_back(bound);

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af66d8f9dda835d55dc3009cf582f87d8"></a><!-- doxytag: member="PostureTransition::setTimeBoundry" ref="af66d8f9dda835d55dc3009cf582f87d8" args="(int, simtime_t, simtime_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::setTimeBoundry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>lowBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&#160;</td>
          <td class="paramname"><em>highBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the given boundary to the existing time domain specified by the given ID . </p>
<p>This function gets an index of an existing time domain and adds the given boundary to the boundary list of that time domain. </p>

<p>References <a class="el" href="a00179.html#a0566260a55d34fde7d6e35103f95785a">timeDomainList</a>.</p>

<p>Referenced by <a class="el" href="a00142.html#a138ebd67882d6cf1154126f47d35d49c">MoBANCoordinator::readConfigurationFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    TimeBound* bound=<span class="keyword">new</span> TimeBound;
    bound-&gt;low = lowBound;
    bound-&gt;high = highBound;

    <a class="code" href="a00179.html#a0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.at(<span class="keywordtype">id</span>)-&gt;boundries.push_back(bound);

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af48e8ee3a857b2425a9f1fe6ded08841"></a><!-- doxytag: member="PostureTransition::subtractMatrix" ref="af48e8ee3a857b2425a9f1fe6ded08841" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::subtractMatrix </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtracts two matrices with dimension numPos*numPose . </p>
<p>Function to subtract two matrix with the known dimensions as number of postures. </p>

<p>References <a class="el" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73">numPos</a>.</p>

<p>Referenced by <a class="el" href="a00179.html#a3ddddcbf58ad8e1edd23cf8023c7b974">extractMatrixFromSteadyState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i,j;
    <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
    {
        <span class="keywordflow">for</span>(j=0; j &lt; <a class="code" href="a00179.html#a88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> ; j++)
            res[i][j] = mat1[i][j] - mat2[i][j];
    }

}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Projects/MiXiM/extsrc/mixim/src/inet_stub/mobility/models/<a class="el" href="a00371_source.html">PostureTransition.h</a></li>
<li>D:/Projects/MiXiM/extsrc/mixim/src/inet_stub/mobility/models/PostureTransition.cc</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00179.html">PostureTransition</a>      </li>

    <li class="footer">Generated on Tue Mar 5 2013 21:26:33 for MiXiM by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
