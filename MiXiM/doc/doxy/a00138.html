<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MiXiM: MappingUtils Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MiXiM
   &#160;<span id="projectnumber">2.3</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00138.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">MappingUtils Class Reference<div class="ingroups"><a class="el" href="a00519.html">mapping - classes representing mathematical mappings</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MappingUtils" -->
<p>Provides several utility methods for Mappings.  
 <a href="a00138.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00300_source.html">MappingUtils.h</a>&gt;</code></p>

<p><a href="a00857.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad235ea24201e93c2b28a1c65c2f4fa6e"></a><!-- doxytag: member="MappingUtils::MappingBuffer" ref="ad235ea24201e93c2b28a1c65c2f4fa6e" args="" -->
typedef std::list&lt; const <br class="typebreak"/>
<a class="el" href="a00058.html">ConstMapping</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MappingBuffer</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#a0c61c76ba04339162563339b23bf42e9">createMapping</a> (const <a class="el" href="a00086.html">DimensionSet</a> &amp;domain=<a class="el" href="a00086.html">DimensionSet</a>(<a class="el" href="a00085.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>), <a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643">Mapping::InterpolationMethod</a> intpl=Mapping::LINEAR)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an appropriate changeable <a class="el" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a> with the specified domain and the specified interpolation method.  <a href="#a0c61c76ba04339162563339b23bf42e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#acca15c41da58e61619e67d1ec1538a9e">createMapping</a> (Mapping::argument_value_cref_t outOfRangeValue, const <a class="el" href="a00086.html">DimensionSet</a> &amp;domain=<a class="el" href="a00086.html">DimensionSet</a>(<a class="el" href="a00085.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>), <a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643">Mapping::InterpolationMethod</a> intpl=Mapping::LINEAR)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an appropriate changeable <a class="el" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a> with the specified domain and the specified interpolation method.  <a href="#acca15c41da58e61619e67d1ec1538a9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a45c56f1ea72b2f8b278d1016ac6228df"></a><!-- doxytag: member="MappingUtils::applyElementWiseOperator" ref="a45c56f1ea72b2f8b278d1016ac6228df" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, const Argument &amp;intvlStart, const Argument &amp;intvlEnd, Operator op)" -->
template&lt;class Operator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>applyElementWiseOperator</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2, const <a class="el" href="a00013.html">Argument</a> &amp;intvlStart, const <a class="el" href="a00013.html">Argument</a> &amp;intvlEnd, Operator op)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2864c33a93f9ce23403d0c84ca9a19e2"></a><!-- doxytag: member="MappingUtils::applyElementWiseOperator" ref="a2864c33a93f9ce23403d0c84ca9a19e2" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Operator op, Mapping::argument_value_cref_t outOfRangeVal=Argument::MappedZero, bool contOutOfRange=true)" -->
template&lt;class Operator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>applyElementWiseOperator</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2, Operator op, Mapping::argument_value_cref_t outOfRangeVal=<a class="el" href="a00013.html#a8523627cdc70492e5e0935b9a3a78cc4">Argument::MappedZero</a>, bool contOutOfRange=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#a11550dc6dc55beb5a14def9ffb501a40">multiply</a> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the passed functions element-wise with each other and returns the result in a new Function.  <a href="#a11550dc6dc55beb5a14def9ffb501a40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d8bf65254d099c87948c1c300986696"></a><!-- doxytag: member="MappingUtils::add" ref="a0d8bf65254d099c87948c1c300986696" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2)" -->
static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37d38fd0a9593e6f055ac8d90758965e"></a><!-- doxytag: member="MappingUtils::subtract" ref="a37d38fd0a9593e6f055ac8d90758965e" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2)" -->
static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>subtract</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ccda215590380a9798e4dd51ede69c"></a><!-- doxytag: member="MappingUtils::divide" ref="ad5ccda215590380a9798e4dd51ede69c" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2)" -->
static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>divide</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab8b49872f55a0162ee1c25f0f4af5b1"></a><!-- doxytag: member="MappingUtils::multiply" ref="aab8b49872f55a0162ee1c25f0f4af5b1" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)" -->
static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>multiply</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a372c8f56f2e7f5dc0ce06daf4e0db128"></a><!-- doxytag: member="MappingUtils::add" ref="a372c8f56f2e7f5dc0ce06daf4e0db128" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)" -->
static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a217539e608efcc8ccf7766c9b9733a17"></a><!-- doxytag: member="MappingUtils::subtract" ref="a217539e608efcc8ccf7766c9b9733a17" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)" -->
static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>subtract</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf2fb8da23ea9c12f9946559fe954c8"></a><!-- doxytag: member="MappingUtils::divide" ref="a2cf2fb8da23ea9c12f9946559fe954c8" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)" -->
static <a class="el" href="a00136.html">Mapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>divide</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;f1, const <a class="el" href="a00058.html">ConstMapping</a> &amp;f2, Mapping::argument_value_cref_t outOfRangeVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Argument::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#afbe1a1e1d2becd66d2c0d5a8ac42b478">findMax</a> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;m, Argument::mapped_type_cref cRetNotFound=<a class="el" href="a00138.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the passed mapping and returns value at the key entry with the highest value.  <a href="#afbe1a1e1d2becd66d2c0d5a8ac42b478"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Argument::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#ac9d1a808dbca5da873af58f1da4cbcf4">findMax</a> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;m, const <a class="el" href="a00013.html">Argument</a> &amp;min, const <a class="el" href="a00013.html">Argument</a> &amp;max, Argument::mapped_type_cref cRetNotFound=<a class="el" href="a00138.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the passed mapping and returns the value at the key entry with the highest value in the range defined by the passed min and max parameter.  <a href="#ac9d1a808dbca5da873af58f1da4cbcf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Argument::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#a5d9c4e3dcaddccfa65f21212d0fee2cf">findMin</a> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;m, Argument::mapped_type_cref cRetNotFound=<a class="el" href="a00138.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the passed mapping and returns value at the key entry with the smallest value.  <a href="#a5d9c4e3dcaddccfa65f21212d0fee2cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Argument::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#adb9e9ced268b9a5d1d4f6d34738654aa">findMin</a> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;m, const <a class="el" href="a00013.html">Argument</a> &amp;min, const <a class="el" href="a00013.html">Argument</a> &amp;max, Argument::mapped_type_cref cRetNotFound=<a class="el" href="a00138.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the passed mapping and returns the value at the key entry with the smallest value in the range defined by the passed min and max parameter.  <a href="#adb9e9ced268b9a5d1d4f6d34738654aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#af1b74160ce464f825e0715f1fc656f5f">addDiscontinuity</a> (<a class="el" href="a00136.html">Mapping</a> *m, const <a class="el" href="a00013.html">Argument</a> &amp;pos, Argument::mapped_type_cref value, simtime_t_cref limitTime, Argument::mapped_type_cref limitValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a discontinuity in time-dimension, i.e. its representation, to a passed mapping.  <a href="#af1b74160ce464f825e0715f1fc656f5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf7c04c0adea7f6e9fe49101b0197c3"></a><!-- doxytag: member="MappingUtils::pre" ref="a2cf7c04c0adea7f6e9fe49101b0197c3" args="(simtime_t_cref t)" -->
static simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#a2cf7c04c0adea7f6e9fe49101b0197c3">pre</a> (simtime_t_cref t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the closest value of simtime before passed value <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31183e79401391df3e2d250846ae8d0e"></a><!-- doxytag: member="MappingUtils::post" ref="a31183e79401391df3e2d250846ae8d0e" args="(simtime_t_cref t)" -->
static simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#a31183e79401391df3e2d250846ae8d0e">post</a> (simtime_t_cref t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the closest value of simtime after passed values <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28683c5c7dcc795157020a36043a1de3"></a><!-- doxytag: member="MappingUtils::incNextPosition" ref="a28683c5c7dcc795157020a36043a1de3" args="(simtime_t_cref t)" -->
static simtime_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#a28683c5c7dcc795157020a36043a1de3">incNextPosition</a> (simtime_t_cref t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the incremented position point (used in <a class="el" href="a00188.html#a082fa16cd2eaa7ac2dd0b16b66660317" title="Helper function that sets member nextPosition. Presumes that iterator it and member position are set ...">RSAMConstMappingIterator::setNextPosition</a>). <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const Argument::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a> = std::numeric_limits&lt;Argument::mapped_type&gt;::infinity()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default value for <a class="el" href="a00138.html#a5d9c4e3dcaddccfa65f21212d0fee2cf" title="Iterates over the passed mapping and returns value at the key entry with the smallest value...">findMin()</a> functions if it does not find a minimum element.  <a href="#a3db893e8948a5af5fe947fb0740d86ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const Argument::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a> = -std::numeric_limits&lt;Argument::mapped_type&gt;::infinity()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default value for <a class="el" href="a00138.html#afbe1a1e1d2becd66d2c0d5a8ac42b478" title="Iterates over the passed mapping and returns value at the key entry with the highest value...">findMax()</a> functions if it does not find a maximum element.  <a href="#a2a3f154e68d94b4b5a5ed580bb3e756f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54b5597499f282d0f2c9dd18894698f9"></a><!-- doxytag: member="MappingUtils::createCompatibleMapping" ref="a54b5597499f282d0f2c9dd18894698f9" args="(const ConstMapping &amp;src, const ConstMapping &amp;dst)" -->
static const <a class="el" href="a00058.html">ConstMapping</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createCompatibleMapping</b> (const <a class="el" href="a00058.html">ConstMapping</a> &amp;src, const <a class="el" href="a00058.html">ConstMapping</a> &amp;dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a768601098bcb0d998be2c742126433"></a><!-- doxytag: member="MappingUtils::iterateToNext" ref="a6a768601098bcb0d998be2c742126433" args="(ConstMappingIterator *it1, ConstMappingIterator *it2)" -->
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>iterateToNext</b> (<a class="el" href="a00059.html">ConstMappingIterator</a> *it1, <a class="el" href="a00059.html">ConstMappingIterator</a> *it2)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Provides several utility methods for Mappings. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Karl Wessel </dd></dl>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af1b74160ce464f825e0715f1fc656f5f"></a><!-- doxytag: member="MappingUtils::addDiscontinuity" ref="af1b74160ce464f825e0715f1fc656f5f" args="(Mapping *m, const Argument &amp;pos, Argument::mapped_type_cref value, simtime_t_cref limitTime, Argument::mapped_type_cref limitValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MappingUtils::addDiscontinuity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00136.html">Mapping</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t_cref&#160;</td>
          <td class="paramname"><em>limitTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&#160;</td>
          <td class="paramname"><em>limitValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a discontinuity in time-dimension, i.e. its representation, to a passed mapping. </p>
<p>This is done by setting a regular entry and a limit-entry. The limit-entry shall be very close to the regular entry (on its left or right).</p>
<p>The implementation works simply by adding the limit-value as a separate entry at the position of the limit-time. This means that this methods adds a total of two entries to the passed mapping.</p>
<p>Note: One should use the methods 'pre' or 'post' provided by <a class="el" href="a00138.html" title="Provides several utility methods for Mappings.">MappingUtils</a> to calculate the limit-time for the discontinuity.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mapping the discontinuity will be added to. </td></tr>
    <tr><td class="paramname">pos</td><td>The position of the regular entry. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the regular entry. </td></tr>
    <tr><td class="paramname">limitTime</td><td>The time-point of the limit-entry. </td></tr>
    <tr><td class="paramname">limitValue</td><td>The value of the limit-entry. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a">Argument::getTime()</a>, <a class="el" href="a00013.html#a8087982f050bdc61d787b128ca9ac8f9">Argument::setTime()</a>, and <a class="el" href="a00136.html#ab8906dfac661d5c6a0a35cf1744f06ed">Mapping::setValue()</a>.</p>

<p>Referenced by <a class="el" href="a00026.html#a23ed373dcfd98255df5f5ffa7e30eec6">BaseMacLayer::createRectangleMapping()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// asserts/preconditions</span>
  <span class="comment">// make sure the time really differs at the discontinuity</span>
  assert(limitTime != pos.<a class="code" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>());

  <span class="comment">// add (pos, value) to mapping</span>
  m-&gt;<a class="code" href="a00136.html#ab8906dfac661d5c6a0a35cf1744f06ed" title="Changes the value of the Mapping at the specified position.">setValue</a>(pos, value);

  <span class="comment">// create Argument limitPos for the limit-position, i.e. copy pos and set limitTime as its time</span>
  <a class="code" href="a00013.html" title="Defines an argument for a mapping.">Argument</a> limitPos = pos;
  limitPos.<a class="code" href="a00013.html#a8087982f050bdc61d787b128ca9ac8f9" title="Changes the time value of this argument.">setTime</a>(limitTime);

  <span class="comment">// add (limitPos, limitValue) to mapping</span>
  m-&gt;<a class="code" href="a00136.html#ab8906dfac661d5c6a0a35cf1744f06ed" title="Changes the value of the Mapping at the specified position.">setValue</a>(limitPos, limitValue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0c61c76ba04339162563339b23bf42e9"></a><!-- doxytag: member="MappingUtils::createMapping" ref="a0c61c76ba04339162563339b23bf42e9" args="(const DimensionSet &amp;domain=DimensionSet(Dimension::time), Mapping::InterpolationMethod intpl=Mapping::LINEAR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00136.html">Mapping</a> * MappingUtils::createMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00086.html">DimensionSet</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code><a class="el" href="a00086.html">DimensionSet</a>(<a class="el" href="a00085.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643">Mapping::InterpolationMethod</a>&#160;</td>
          <td class="paramname"><em>intpl</em> = <code>Mapping::LINEAR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an appropriate changeable <a class="el" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a> with the specified domain and the specified interpolation method. </p>
<p>Note: The interpolation method is always linear, at the moment. </p>

<p>References <a class="el" href="a00086.html#a015cb6fa6c77b26b8c7b1e65827b8342">DimensionSet::hasDimension()</a>, <a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b">Mapping::LINEAR</a>, <a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01">Mapping::NEAREST</a>, <a class="el" href="a00086.html#a0bf532a8e4cbf151337d24b7246790a9">DimensionSet::size()</a>, <a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f">Mapping::STEPS</a>, and <a class="el" href="a00085.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>.</p>

<p>Referenced by <a class="el" href="a00020.html#a53eb943cea4604171a5c1cc4cdec4c20">BaseDecider::calculateRSSIMapping()</a>, <a class="el" href="a00026.html#a1c05648ce7d11bc767f9acd3d64ee067">BaseMacLayer::createConstantMapping()</a>, <a class="el" href="a00026.html#a23ed373dcfd98255df5f5ffa7e30eec6">BaseMacLayer::createRectangleMapping()</a>, <a class="el" href="a00128.html#a3a62f334346a15619853a8c6c87367aa">Mac80211::createSignal()</a>, <a class="el" href="a00026.html#a3da0a0f34a80528e6efcb5593a073c55">BaseMacLayer::createSingleFrequencyMapping()</a>, <a class="el" href="a00184.html#a9c8c9efca7849ffb32d315a71d2a7184">RandomFreqTimeModel::filterSignal()</a>, <a class="el" href="a00185.html#acac71950a5a7176292f7c404c32f609c">RandomFrequencyOnlyModel::filterSignal()</a>, and <a class="el" href="a00127.html#ac7fd9376f5521851bd3888d99dc451c2">LogNormalShadowing::filterSignal()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                 {
  assert(domain.<a class="code" href="a00086.html#a015cb6fa6c77b26b8c7b1e65827b8342" title="Returns true if the passed Dimension is inside this DimensionSet.">hasDimension</a>(<a class="code" href="a00085.html#a16cb1f186dd3f48d33a4aebe948001d7" title="Shortcut to the time Dimension, same as &#39;Dimension(&quot;time&quot;)&#39;, but spares the parsing of a string...">Dimension::time</a>));

  <span class="keywordflow">if</span>(domain.<a class="code" href="a00086.html#a0bf532a8e4cbf151337d24b7246790a9" title="Returns the size of the DimensionSet.">size</a>() == 1){
    <span class="keywordflow">switch</span>(intpl){
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b" title="interpolates linear with next lower and next upper entry constant before the first and after the last...">Mapping::LINEAR</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00212.html">TimeMapping&lt;Linear&gt;</a>();
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01" title="interpolates with nearest entry">Mapping::NEAREST</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00212.html" title="Implements the Mapping-interface with an InterpolateableMap from simtime_t to double between which va...">TimeMapping&lt;Nearest&gt;</a>();
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f" title="interpolates with next lower entry">Mapping::STEPS</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00212.html" title="Implements the Mapping-interface with an InterpolateableMap from simtime_t to double between which va...">TimeMapping&lt;NextSmaller&gt;</a>();
      <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> 0;
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">switch</span>(intpl){
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b" title="interpolates linear with next lower and next upper entry constant before the first and after the last...">Mapping::LINEAR</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00148.html">MultiDimMapping&lt;Linear&gt;</a>(domain);
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01" title="interpolates with nearest entry">Mapping::NEAREST</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00148.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional instances of...">MultiDimMapping&lt;Nearest&gt;</a>(domain);
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f" title="interpolates with next lower entry">Mapping::STEPS</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00148.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional instances of...">MultiDimMapping&lt;NextSmaller&gt;</a>(domain);
      <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> 0;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acca15c41da58e61619e67d1ec1538a9e"></a><!-- doxytag: member="MappingUtils::createMapping" ref="acca15c41da58e61619e67d1ec1538a9e" args="(Mapping::argument_value_cref_t outOfRangeValue, const DimensionSet &amp;domain=DimensionSet(Dimension::time), Mapping::InterpolationMethod intpl=Mapping::LINEAR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00136.html">Mapping</a> * MappingUtils::createMapping </td>
          <td>(</td>
          <td class="paramtype">Mapping::argument_value_cref_t&#160;</td>
          <td class="paramname"><em>outOfRangeValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00086.html">DimensionSet</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code><a class="el" href="a00086.html">DimensionSet</a>(<a class="el" href="a00085.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643">Mapping::InterpolationMethod</a>&#160;</td>
          <td class="paramname"><em>intpl</em> = <code>Mapping::LINEAR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an appropriate changeable <a class="el" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a> with the specified domain and the specified interpolation method. </p>
<p>Note: The interpolation method is always linear, at the moment. </p>

<p>References <a class="el" href="a00086.html#a015cb6fa6c77b26b8c7b1e65827b8342">DimensionSet::hasDimension()</a>, <a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b">Mapping::LINEAR</a>, <a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01">Mapping::NEAREST</a>, <a class="el" href="a00086.html#a0bf532a8e4cbf151337d24b7246790a9">DimensionSet::size()</a>, <a class="el" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f">Mapping::STEPS</a>, and <a class="el" href="a00085.html#a16cb1f186dd3f48d33a4aebe948001d7">Dimension::time</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                                             {
  assert(domain.<a class="code" href="a00086.html#a015cb6fa6c77b26b8c7b1e65827b8342" title="Returns true if the passed Dimension is inside this DimensionSet.">hasDimension</a>(<a class="code" href="a00085.html#a16cb1f186dd3f48d33a4aebe948001d7" title="Shortcut to the time Dimension, same as &#39;Dimension(&quot;time&quot;)&#39;, but spares the parsing of a string...">Dimension::time</a>));

  <span class="keywordflow">if</span>(domain.<a class="code" href="a00086.html#a0bf532a8e4cbf151337d24b7246790a9" title="Returns the size of the DimensionSet.">size</a>() == 1){
    <span class="keywordflow">switch</span>(intpl){
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b" title="interpolates linear with next lower and next upper entry constant before the first and after the last...">Mapping::LINEAR</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00212.html">TimeMapping&lt;Linear&gt;</a>(outOfRangeVal);
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01" title="interpolates with nearest entry">Mapping::NEAREST</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00212.html" title="Implements the Mapping-interface with an InterpolateableMap from simtime_t to double between which va...">TimeMapping&lt;Nearest&gt;</a>(outOfRangeVal);
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f" title="interpolates with next lower entry">Mapping::STEPS</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00212.html" title="Implements the Mapping-interface with an InterpolateableMap from simtime_t to double between which va...">TimeMapping&lt;NextSmaller&gt;</a>(outOfRangeVal);
      <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> 0;
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">switch</span>(intpl){
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643ac8a952576b8d13258ba0f3c0f1584f9b" title="interpolates linear with next lower and next upper entry constant before the first and after the last...">Mapping::LINEAR</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00148.html">MultiDimMapping&lt;Linear&gt;</a>(domain, outOfRangeVal);
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643afc951c0875bda3e7b8f6a9f7d4e90d01" title="interpolates with nearest entry">Mapping::NEAREST</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00148.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional instances of...">MultiDimMapping&lt;Nearest&gt;</a>(domain, outOfRangeVal);
      <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="a00136.html#aa713c0cd84f74727888bef5b9e8b0643a14b1d21bd98ca6e7e77dca120dd5eb0f" title="interpolates with next lower entry">Mapping::STEPS</a>:
      <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="a00148.html" title="Implementation of the Mapping-interface which is able to represent arbitrary dimensional instances of...">MultiDimMapping&lt;NextSmaller&gt;</a>(domain, outOfRangeVal);
      <span class="keywordflow">break</span>;
    }
    <span class="keywordflow">return</span> 0;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="afbe1a1e1d2becd66d2c0d5a8ac42b478"></a><!-- doxytag: member="MappingUtils::findMax" ref="afbe1a1e1d2becd66d2c0d5a8ac42b478" args="(const ConstMapping &amp;m, Argument::mapped_type_cref cRetNotFound=cMaxNotFound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::argument_value_t MappingUtils::findMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00058.html">ConstMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&#160;</td>
          <td class="paramname"><em>cRetNotFound</em> = <code><a class="el" href="a00138.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the passed mapping and returns value at the key entry with the highest value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The map where the maximum value shall be searched. </td></tr>
    <tr><td class="paramname">cRetNotFound</td><td>The value which shall be returned if no maximum was found (default <a class="el" href="a00138.html#a2a3f154e68d94b4b5a5ed580bb3e756f" title="The default value for findMax() functions if it does not find a maximum element.">MappingUtils::cMaxNotFound</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value at the key entry with the highest value or <code>cRetNotFound</code> if map is empty. </dd></dl>

<p>References <a class="el" href="a00058.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274">ConstMapping::createConstIterator()</a>, <a class="el" href="a00059.html#ad4419c259e747867f003d07d62d4259f">ConstMappingIterator::getValue()</a>, <a class="el" href="a00059.html#ad4bac7233c154b7086c6124d2e21be49">ConstMappingIterator::hasNext()</a>, <a class="el" href="a00059.html#a4a6348a453418da95978e570fec046fc">ConstMappingIterator::inRange()</a>, and <a class="el" href="a00059.html#afdafa6870cd19b3d35674a7bc777585d">ConstMappingIterator::next()</a>.</p>

<p>Referenced by <a class="el" href="a00071.html#a0be01ad3cb9198b895cc7a0424a26609">Decider80211::calcChannelSenseRSSI()</a>, and <a class="el" href="a00020.html#ac7a2b437d463db0f1f8f85d5a9685c2c">BaseDecider::calcChannelSenseRSSI()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                            {
  <a class="code" href="a00059.html" title="Defines an const iterator for a ConstMapping which is able to iterate over the Mapping.">ConstMappingIterator</a>*     it       = m.<a class="code" href="a00058.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274" title="Returns a pointer of a new Iterator which is able to iterate over this Mapping.">createConstIterator</a>();
  <span class="keywordtype">bool</span>                      bIsFirst = <span class="keyword">true</span>;
  Mapping::argument_value_t res;

  <span class="keywordflow">while</span>(it-&gt;<a class="code" href="a00059.html#a4a6348a453418da95978e570fec046fc" title="Returns true if the current position of the iterator is in range of the function.">inRange</a>()){
    Mapping::argument_value_cref_t val = it-&gt;<a class="code" href="a00059.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
    <span class="keywordflow">if</span>(bIsFirst || val &gt; res) {
      res      = val;
      bIsFirst = <span class="keyword">false</span>;
    }

    <span class="comment">//std::cerr &lt;&lt; &quot;findMax(): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; max is now: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
    <span class="keywordflow">if</span>(!it-&gt;<a class="code" href="a00059.html#ad4bac7233c154b7086c6124d2e21be49" title="Returns true if the iterator has a next value it can iterate to on a call to &quot;next()&quot;.">hasNext</a>())
      <span class="keywordflow">break</span>;

    it-&gt;<a class="code" href="a00059.html#afdafa6870cd19b3d35674a7bc777585d" title="Iterates to the next position of the Mapping.">next</a>();
  }
  <span class="keyword">delete</span> it;
  <span class="keywordflow">if</span> (bIsFirst) {
    <span class="comment">// no maximum available, maybe map is empty</span>
    <span class="keywordflow">return</span> cRetNotFound;
  }
  <span class="keywordflow">return</span> res;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac9d1a808dbca5da873af58f1da4cbcf4"></a><!-- doxytag: member="MappingUtils::findMax" ref="ac9d1a808dbca5da873af58f1da4cbcf4" args="(const ConstMapping &amp;m, const Argument &amp;min, const Argument &amp;max, Argument::mapped_type_cref cRetNotFound=cMaxNotFound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::argument_value_t MappingUtils::findMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00058.html">ConstMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&#160;</td>
          <td class="paramname"><em>cRetNotFound</em> = <code><a class="el" href="a00138.html#a2a3f154e68d94b4b5a5ed580bb3e756f">cMaxNotFound</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the passed mapping and returns the value at the key entry with the highest value in the range defined by the passed min and max parameter. </p>
<p>The area defined by the min and max parameter is the number of key entries which position in each dimension is bigger or equal than the value of the min parameter in that dimension and smaller or equal than max parameter in that dimension.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The map where the maximum value shall be searched. </td></tr>
    <tr><td class="paramname">min</td><td>The beginning of search range. </td></tr>
    <tr><td class="paramname">max</td><td>The end of search range. </td></tr>
    <tr><td class="paramname">cRetNotFound</td><td>The value which shall be returned if no maximum was found (default <a class="el" href="a00138.html#a2a3f154e68d94b4b5a5ed580bb3e756f" title="The default value for findMax() functions if it does not find a maximum element.">MappingUtils::cMaxNotFound</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value at the key entry with the highest value or <code>cRetNotFound</code> if map is empty or no element in range [min,max]. </dd></dl>

<p>References <a class="el" href="a00013.html#af0e836fd4aaecc1461b994e21f66ddc3">Argument::begin()</a>, <a class="el" href="a00058.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274">ConstMapping::createConstIterator()</a>, <a class="el" href="a00013.html#aeeb6730c20ae8a8d6c9606f2e03cc1da">Argument::end()</a>, <a class="el" href="a00013.html#a137a911de0281cbb519fe13727aa0813">Argument::getArgValue()</a>, <a class="el" href="a00013.html#a8b3fcda23d2eec4e931126d261e4b194">Argument::getDimensions()</a>, <a class="el" href="a00058.html#acc1559cf5741bec3aa6422e94c5b9cce">ConstMapping::getDimensionSet()</a>, <a class="el" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a">Argument::getTime()</a>, <a class="el" href="a00059.html#ad4419c259e747867f003d07d62d4259f">ConstMappingIterator::getValue()</a>, and <a class="el" href="a00086.html#aae6d8ce3a87e3e1571b97c92f11363fb">DimensionSet::isSubSet()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                                                                 {
  <span class="keyword">const</span> <a class="code" href="a00086.html" title="Represents a set of dimensions which is used to define over which dimensions a mapping is defined (th...">DimensionSet</a>&amp; rDimSet = m.<a class="code" href="a00058.html#acc1559cf5741bec3aa6422e94c5b9cce" title="Returns this Mappings domain as DimensionSet.">getDimensionSet</a>();
  <span class="comment">//the passed interval should define a value for every dimension</span>
  <span class="comment">//of the mapping.</span>
  assert(pRangeFrom.getDimensions().isSubSet(rDimSet));
  assert(pRangeTo.getDimensions().isSubSet(rDimSet));

  <a class="code" href="a00059.html" title="Defines an const iterator for a ConstMapping which is able to iterate over the Mapping.">ConstMappingIterator</a>*     it       = m.<a class="code" href="a00058.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274" title="Returns a pointer of a new Iterator which is able to iterate over this Mapping.">createConstIterator</a>(pRangeFrom);
  <span class="keywordtype">bool</span>                      bIsFirst = <span class="keyword">true</span>;
  Mapping::argument_value_t res;

  <span class="comment">//std::cerr &lt;&lt; &quot;findMax(m, &quot; &lt;&lt; pRangeFrom &lt;&lt; &quot;, &quot; &lt;&lt; pRangeTo &lt;&lt; &quot;): Map is&quot; &lt;&lt; std::endl &lt;&lt; m;</span>
  <span class="keywordflow">if</span> (it-&gt;inRange()) {
    res      = it-&gt;getValue();
    bIsFirst = <span class="keyword">false</span>;
    <span class="comment">//std::cerr &lt;&lt; &quot;findMax(...):  &quot; &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; max is at beginning: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
  }
  <span class="keywordflow">while</span>(it-&gt;hasNext() &amp;&amp; it-&gt;getNextPosition().compare(pRangeTo, &amp;rDimSet) &lt; 0){
    it-&gt;next();

    <span class="keyword">const</span> <a class="code" href="a00013.html" title="Defines an argument for a mapping.">Argument</a>&amp; next    = it-&gt;getPosition();
    <span class="keywordtype">bool</span>            inRange = pRangeFrom.<a class="code" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &lt;= next.<a class="code" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &amp;&amp; next.<a class="code" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &lt;= pRangeTo.getTime();
    <span class="keywordflow">if</span>(inRange) {
      <span class="keyword">const</span> <a class="code" href="a00013.html#a521abc97d737e8c77742dcc9f4b21022" title="Const-iterator type for this set.">Argument::const_iterator</a> itAEnd = next.<a class="code" href="a00013.html#aeeb6730c20ae8a8d6c9606f2e03cc1da" title="Returns an iterator to the value behind the last argument value.">end</a>();
      <span class="keywordflow">for</span>(<a class="code" href="a00013.html#a521abc97d737e8c77742dcc9f4b21022" title="Const-iterator type for this set.">Argument::const_iterator</a> itA = next.<a class="code" href="a00013.html#af0e836fd4aaecc1461b994e21f66ddc3" title="Returns an iterator to the first argument value in this Argument.">begin</a>(); itA != itAEnd; ++itA) {
        <span class="keywordflow">if</span>(pRangeFrom.getArgValue(itA-&gt;first) &gt; itA-&gt;second || itA-&gt;second &gt; pRangeTo.getArgValue(itA-&gt;first)) {
          inRange = <span class="keyword">false</span>;
          <span class="keywordflow">break</span>;
        }
      }
    }
    <span class="keywordflow">if</span>(inRange) {
      Mapping::argument_value_cref_t val = it-&gt;getValue();
      <span class="keywordflow">if</span>(bIsFirst || val &gt; res) {
        res      = val;
        bIsFirst = <span class="keyword">false</span>;
      }
      <span class="comment">//std::cerr &lt;&lt; &quot;findMax(...): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; max is now: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
    }
  }
  it-&gt;iterateTo(pRangeTo);
  <span class="keywordflow">if</span> (it-&gt;inRange()) {
    Mapping::argument_value_cref_t val = it-&gt;getValue();
    <span class="keywordflow">if</span>(bIsFirst || val &gt; res) {
      res      = val;
      bIsFirst = <span class="keyword">false</span>;
    }
    <span class="comment">//std::cerr &lt;&lt; &quot;findMax(...): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; max is finally: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
  }
  <span class="keyword">delete</span> it;
  <span class="keywordflow">if</span> (bIsFirst) {
    <span class="comment">// no minimum available</span>
    <span class="keywordflow">return</span> cRetNotFound;
  }
  <span class="keywordflow">return</span> res;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5d9c4e3dcaddccfa65f21212d0fee2cf"></a><!-- doxytag: member="MappingUtils::findMin" ref="a5d9c4e3dcaddccfa65f21212d0fee2cf" args="(const ConstMapping &amp;m, Argument::mapped_type_cref cRetNotFound=cMinNotFound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::argument_value_t MappingUtils::findMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00058.html">ConstMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&#160;</td>
          <td class="paramname"><em>cRetNotFound</em> = <code><a class="el" href="a00138.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the passed mapping and returns value at the key entry with the smallest value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The map where the minimum value shall be searched. </td></tr>
    <tr><td class="paramname">cRetNotFound</td><td>The value which shall be returned if no minimum was found (default <a class="el" href="a00138.html#a3db893e8948a5af5fe947fb0740d86ca" title="The default value for findMin() functions if it does not find a minimum element.">MappingUtils::cMinNotFound</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value at the key entry with the lowest value or <code>cRetNotFound</code> if map is empty. </dd></dl>

<p>References <a class="el" href="a00058.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274">ConstMapping::createConstIterator()</a>, <a class="el" href="a00059.html#ad4419c259e747867f003d07d62d4259f">ConstMappingIterator::getValue()</a>, <a class="el" href="a00059.html#ad4bac7233c154b7086c6124d2e21be49">ConstMappingIterator::hasNext()</a>, <a class="el" href="a00059.html#a4a6348a453418da95978e570fec046fc">ConstMappingIterator::inRange()</a>, and <a class="el" href="a00059.html#afdafa6870cd19b3d35674a7bc777585d">ConstMappingIterator::next()</a>.</p>

<p>Referenced by <a class="el" href="a00071.html#ae8d8435cae6ef92cc9bf8008e0bb56e4">Decider80211::createResult()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                            {
  <a class="code" href="a00059.html" title="Defines an const iterator for a ConstMapping which is able to iterate over the Mapping.">ConstMappingIterator</a>*     it       = m.<a class="code" href="a00058.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274" title="Returns a pointer of a new Iterator which is able to iterate over this Mapping.">createConstIterator</a>();
  <span class="keywordtype">bool</span>                      bIsFirst = <span class="keyword">true</span>;
  Mapping::argument_value_t res;

  <span class="keywordflow">while</span>(it-&gt;<a class="code" href="a00059.html#a4a6348a453418da95978e570fec046fc" title="Returns true if the current position of the iterator is in range of the function.">inRange</a>()) {
    Mapping::argument_value_cref_t val = it-&gt;<a class="code" href="a00059.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
    <span class="keywordflow">if</span>(bIsFirst || val &lt; res) {
      res      = val;
      bIsFirst = <span class="keyword">false</span>;
    }

    <span class="comment">//std::cerr &lt;&lt; &quot;findMin(): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; min is now: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
    <span class="keywordflow">if</span>(!it-&gt;<a class="code" href="a00059.html#ad4bac7233c154b7086c6124d2e21be49" title="Returns true if the iterator has a next value it can iterate to on a call to &quot;next()&quot;.">hasNext</a>())
      <span class="keywordflow">break</span>;

    it-&gt;<a class="code" href="a00059.html#afdafa6870cd19b3d35674a7bc777585d" title="Iterates to the next position of the Mapping.">next</a>();
  }
  <span class="keyword">delete</span> it;
  <span class="keywordflow">if</span> (bIsFirst) {
    <span class="comment">// no minimum available, maybe map is empty</span>
    <span class="keywordflow">return</span> cRetNotFound;
  }
  <span class="keywordflow">return</span> res;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adb9e9ced268b9a5d1d4f6d34738654aa"></a><!-- doxytag: member="MappingUtils::findMin" ref="adb9e9ced268b9a5d1d4f6d34738654aa" args="(const ConstMapping &amp;m, const Argument &amp;min, const Argument &amp;max, Argument::mapped_type_cref cRetNotFound=cMinNotFound)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mapping::argument_value_t MappingUtils::findMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00058.html">ConstMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html">Argument</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Argument::mapped_type_cref&#160;</td>
          <td class="paramname"><em>cRetNotFound</em> = <code><a class="el" href="a00138.html#a3db893e8948a5af5fe947fb0740d86ca">cMinNotFound</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the passed mapping and returns the value at the key entry with the smallest value in the range defined by the passed min and max parameter. </p>
<p>The area defined by the min and max parameter is the number of key entries which position in each dimension is bigger or equal than the value of the min parameter in that dimension and smaller or equal than max parameter in that dimension.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The map where the minimum value shall be searched. </td></tr>
    <tr><td class="paramname">min</td><td>The beginning of search range. </td></tr>
    <tr><td class="paramname">max</td><td>The end of search range. </td></tr>
    <tr><td class="paramname">cRetNotFound</td><td>The value which shall be returned if no minimum was found (default <a class="el" href="a00138.html#a3db893e8948a5af5fe947fb0740d86ca" title="The default value for findMin() functions if it does not find a minimum element.">MappingUtils::cMinNotFound</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value at the key entry with the highest value or <code>cRetNotFound</code> if map is empty or no element in range [min,max]. </dd></dl>

<p>References <a class="el" href="a00013.html#af0e836fd4aaecc1461b994e21f66ddc3">Argument::begin()</a>, <a class="el" href="a00013.html#ac983761168238481be2bc9d9d180abe5">Argument::compare()</a>, <a class="el" href="a00058.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274">ConstMapping::createConstIterator()</a>, <a class="el" href="a00013.html#aeeb6730c20ae8a8d6c9606f2e03cc1da">Argument::end()</a>, <a class="el" href="a00013.html#a137a911de0281cbb519fe13727aa0813">Argument::getArgValue()</a>, <a class="el" href="a00013.html#a8b3fcda23d2eec4e931126d261e4b194">Argument::getDimensions()</a>, <a class="el" href="a00058.html#acc1559cf5741bec3aa6422e94c5b9cce">ConstMapping::getDimensionSet()</a>, <a class="el" href="a00059.html#a1f4cae3b170754a76049b8e81b2e3c07">ConstMappingIterator::getNextPosition()</a>, <a class="el" href="a00059.html#a047e853613d5a19ff34526d0cff8fcf9">ConstMappingIterator::getPosition()</a>, <a class="el" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a">Argument::getTime()</a>, <a class="el" href="a00059.html#ad4419c259e747867f003d07d62d4259f">ConstMappingIterator::getValue()</a>, <a class="el" href="a00059.html#ad4bac7233c154b7086c6124d2e21be49">ConstMappingIterator::hasNext()</a>, <a class="el" href="a00059.html#a4a6348a453418da95978e570fec046fc">ConstMappingIterator::inRange()</a>, <a class="el" href="a00086.html#aae6d8ce3a87e3e1571b97c92f11363fb">DimensionSet::isSubSet()</a>, <a class="el" href="a00059.html#a607d741e2d841265851a85670f247c46">ConstMappingIterator::iterateTo()</a>, and <a class="el" href="a00059.html#afdafa6870cd19b3d35674a7bc777585d">ConstMappingIterator::next()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                                                                  {
  <span class="keyword">const</span> <a class="code" href="a00086.html" title="Represents a set of dimensions which is used to define over which dimensions a mapping is defined (th...">DimensionSet</a>&amp; rDimSet = m.<a class="code" href="a00058.html#acc1559cf5741bec3aa6422e94c5b9cce" title="Returns this Mappings domain as DimensionSet.">getDimensionSet</a>();
  <span class="comment">//the passed interval should define a value for every dimension</span>
  <span class="comment">//of the mapping.</span>
  assert(pRangeFrom.getDimensions().isSubSet(rDimSet));
  assert(pRangeTo.getDimensions().isSubSet(rDimSet));

  Mapping::argument_value_t res;
  <span class="keywordtype">bool</span>                      bIsFirst = <span class="keyword">true</span>;
  <a class="code" href="a00059.html" title="Defines an const iterator for a ConstMapping which is able to iterate over the Mapping.">ConstMappingIterator</a>*     it       = m.<a class="code" href="a00058.html#a5ff3a15fe6d536fa7a26a3fe1ff1b274" title="Returns a pointer of a new Iterator which is able to iterate over this Mapping.">createConstIterator</a>(pRangeFrom);

  <span class="comment">//std::cerr &lt;&lt; &quot;findMin(m, &quot; &lt;&lt; pRangeFrom &lt;&lt; &quot;, &quot; &lt;&lt; pRangeTo &lt;&lt; &quot;): Map is&quot; &lt;&lt; std::endl &lt;&lt; m;</span>
  <span class="keywordflow">if</span> (it-&gt;<a class="code" href="a00059.html#a4a6348a453418da95978e570fec046fc" title="Returns true if the current position of the iterator is in range of the function.">inRange</a>()) {
    res      = it-&gt;<a class="code" href="a00059.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
    bIsFirst = <span class="keyword">false</span>;
    <span class="comment">//std::cerr &lt;&lt; &quot;findMin(...):  &quot; &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; min is at beginning: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
  }
  <span class="keywordflow">while</span>(it-&gt;<a class="code" href="a00059.html#ad4bac7233c154b7086c6124d2e21be49" title="Returns true if the iterator has a next value it can iterate to on a call to &quot;next()&quot;.">hasNext</a>() &amp;&amp; it-&gt;<a class="code" href="a00059.html#a1f4cae3b170754a76049b8e81b2e3c07" title="Returns the position the next call to &quot;next()&quot; of this Iterator would iterate to.">getNextPosition</a>().<a class="code" href="a00013.html#ac983761168238481be2bc9d9d180abe5" title="Compares this Argument with the passed Argument in the dimensions of the passed DimensionsSet. (Every other Dimension is asserted equal).">compare</a>(pRangeTo, &amp;rDimSet) &lt; 0) {
    it-&gt;<a class="code" href="a00059.html#afdafa6870cd19b3d35674a7bc777585d" title="Iterates to the next position of the Mapping.">next</a>();

    <span class="keyword">const</span> <a class="code" href="a00013.html" title="Defines an argument for a mapping.">Argument</a>&amp; next    = it-&gt;<a class="code" href="a00059.html#a047e853613d5a19ff34526d0cff8fcf9" title="Returns the current position of the iterator.">getPosition</a>();
    <span class="keywordtype">bool</span>            inRange = pRangeFrom.<a class="code" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &lt;= next.<a class="code" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>()  &amp;&amp; next.<a class="code" href="a00013.html#a2ecb3b041b5b8721d6767531e4ac792a" title="Returns the time value of this argument.">getTime</a>() &lt;= pRangeTo.getTime();
    <span class="keywordflow">if</span>(inRange) {
      <span class="keyword">const</span> <a class="code" href="a00013.html#a521abc97d737e8c77742dcc9f4b21022" title="Const-iterator type for this set.">Argument::const_iterator</a> itAEnd = next.<a class="code" href="a00013.html#aeeb6730c20ae8a8d6c9606f2e03cc1da" title="Returns an iterator to the value behind the last argument value.">end</a>();
      <span class="keywordflow">for</span>(<a class="code" href="a00013.html#a521abc97d737e8c77742dcc9f4b21022" title="Const-iterator type for this set.">Argument::const_iterator</a> itA = next.<a class="code" href="a00013.html#af0e836fd4aaecc1461b994e21f66ddc3" title="Returns an iterator to the first argument value in this Argument.">begin</a>(); itA != itAEnd; ++itA) {
        <span class="keywordflow">if</span>(pRangeFrom.getArgValue(itA-&gt;first) &gt; itA-&gt;second || itA-&gt;second &gt; pRangeTo.getArgValue(itA-&gt;first)) {
          inRange = <span class="keyword">false</span>;
          <span class="keywordflow">break</span>;
        }
      }
    }
    <span class="keywordflow">if</span>(inRange) {
      Mapping::argument_value_cref_t val = it-&gt;<a class="code" href="a00059.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
      <span class="keywordflow">if</span>(bIsFirst || val &lt; res) {
        res      = val;
        bIsFirst = <span class="keyword">false</span>;
      }
      <span class="comment">//std::cerr &lt;&lt; &quot;findMin(...): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; min is now: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
    }
  }
  it-&gt;<a class="code" href="a00059.html#a607d741e2d841265851a85670f247c46" title="Iterates to the specified position. This method should be used if the new position is near the curren...">iterateTo</a>(pRangeTo);
  <span class="keywordflow">if</span> (it-&gt;<a class="code" href="a00059.html#a4a6348a453418da95978e570fec046fc" title="Returns true if the current position of the iterator is in range of the function.">inRange</a>()) {
    Mapping::argument_value_cref_t val = it-&gt;<a class="code" href="a00059.html#ad4419c259e747867f003d07d62d4259f" title="Returns the value of the Mapping at the current position.">getValue</a>();
    <span class="keywordflow">if</span>(bIsFirst || val &lt; res) {
      res      = val;
      bIsFirst = <span class="keyword">false</span>;
    }
    <span class="comment">//std::cerr &lt;&lt; &quot;findMin(...): &quot; &lt;&lt; val &lt;&lt; &quot; @ &quot; &lt;&lt; it-&gt;getPosition() &lt;&lt; &quot;; min is finally: &quot; &lt;&lt; res &lt;&lt; std::endl;</span>
  }
  <span class="keyword">delete</span> it;
  <span class="keywordflow">if</span> (bIsFirst) {
    <span class="comment">// no minimum available</span>
    <span class="keywordflow">return</span> cRetNotFound;
  }
  <span class="keywordflow">return</span> res;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a11550dc6dc55beb5a14def9ffb501a40"></a><!-- doxytag: member="MappingUtils::multiply" ref="a11550dc6dc55beb5a14def9ffb501a40" args="(const ConstMapping &amp;f1, const ConstMapping &amp;f2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00136.html">Mapping</a> * MappingUtils::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00058.html">ConstMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00058.html">ConstMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies the passed functions element-wise with each other and returns the result in a new Function. </p>
<p>The domain (<a class="el" href="a00086.html" title="Represents a set of dimensions which is used to define over which dimensions a mapping is defined (th...">DimensionSet</a>) of the result is defined by the domain of the first operand. The domain of the second <a class="el" href="a00136.html" title="Represents a changeable mapping (mathematical function) from at least time to Argument::mapped_type.">Mapping</a> has to be a subset of the domain of the first mapping. </p>

<p>Referenced by <a class="el" href="a00209.html#a6e559163ddd38ef6256b9faa67a46e63">ThresholdDecider::handleSignalOver()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> applyElementWiseOperator(f1, f2, std::multiplies&lt;Mapping::argument_value_t&gt;());
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2a3f154e68d94b4b5a5ed580bb3e756f"></a><!-- doxytag: member="MappingUtils::cMaxNotFound" ref="a2a3f154e68d94b4b5a5ed580bb3e756f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Argument::mapped_type <a class="el" href="a00138.html#a2a3f154e68d94b4b5a5ed580bb3e756f">MappingUtils::cMaxNotFound</a> = -std::numeric_limits&lt;Argument::mapped_type&gt;::infinity()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default value for <a class="el" href="a00138.html#afbe1a1e1d2becd66d2c0d5a8ac42b478" title="Iterates over the passed mapping and returns value at the key entry with the highest value...">findMax()</a> functions if it does not find a maximum element. </p>
<p>It will be initialized with the negative infinity value. </p>

</div>
</div>
<a class="anchor" id="a3db893e8948a5af5fe947fb0740d86ca"></a><!-- doxytag: member="MappingUtils::cMinNotFound" ref="a3db893e8948a5af5fe947fb0740d86ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Argument::mapped_type <a class="el" href="a00138.html#a3db893e8948a5af5fe947fb0740d86ca">MappingUtils::cMinNotFound</a> = std::numeric_limits&lt;Argument::mapped_type&gt;::infinity()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default value for <a class="el" href="a00138.html#a5d9c4e3dcaddccfa65f21212d0fee2cf" title="Iterates over the passed mapping and returns value at the key entry with the smallest value...">findMin()</a> functions if it does not find a minimum element. </p>
<p>It will be initialized with the infinity value. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Projects/MiXiM/extsrc/mixim/src/base/phyLayer/<a class="el" href="a00300_source.html">MappingUtils.h</a></li>
<li>D:/Projects/MiXiM/extsrc/mixim/src/base/phyLayer/MappingUtils.cc</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00138.html">MappingUtils</a>      </li>

    <li class="footer">Generated on Tue Mar 5 2013 21:26:32 for MiXiM by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
